<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <meta name="generator" content="sphinx-5.1.1, furo 2022.06.21"/>
        <title>ehrapy.preprocessing._data_imputation - ehrapy</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=40978830699223671f4072448e654b5958f38b89" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/override.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/sphinx_gallery.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: #003262;
  --color-brand-content: #003262;
  --admonition-font-size: var(--font-size-normal);
  --admonition-title-font-size: var(--font-size-normal);
  --code-font-size: var(--font-size--small);
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">ehrapy</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../../_static/ehrapy_pure.png" alt="Logo"/>
  </div>
  
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../usage/usage.html">Usage</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/io/ehrapy.io.read_csv.html">ehrapy.io.read_csv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/io/ehrapy.io.read_h5ad.html">ehrapy.io.read_h5ad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/io/ehrapy.io.read_pdf.html">ehrapy.io.read_pdf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/io/ehrapy.io.write.html">ehrapy.io.write</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.mimic_2.html">ehrapy.data.mimic_2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.mimic_3_demo.html">ehrapy.data.mimic_3_demo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.diabetes_130.html">ehrapy.data.diabetes_130</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.heart_failure.html">ehrapy.data.heart_failure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.chronic_kidney_disease.html">ehrapy.data.chronic_kidney_disease</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.breast_tissue.html">ehrapy.data.breast_tissue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.cervical_cancer_risk_factors.html">ehrapy.data.cervical_cancer_risk_factors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.dermatology.html">ehrapy.data.dermatology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.echocardiogram.html">ehrapy.data.echocardiogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.heart_disease.html">ehrapy.data.heart_disease</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.hepatitis.html">ehrapy.data.hepatitis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.statlog_heart.html">ehrapy.data.statlog_heart</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.thyroid.html">ehrapy.data.thyroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.breast_cancer_coimbra.html">ehrapy.data.breast_cancer_coimbra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.parkinson_dataset_with_replicated_acoustic_features.html">ehrapy.data.parkinson_dataset_with_replicated_acoustic_features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.parkinsons.html">ehrapy.data.parkinsons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.parkinsons_disease_classification.html">ehrapy.data.parkinsons_disease_classification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.parkinsons_telemonitoring.html">ehrapy.data.parkinsons_telemonitoring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.pca.html">ehrapy.preprocessing.pca</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.regress_out.html">ehrapy.preprocessing.regress_out</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.subsample.html">ehrapy.preprocessing.subsample</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.highly_variable_features.html">ehrapy.preprocessing.highly_variable_features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.qc_metrics.html">ehrapy.preprocessing.qc_metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.qc_lab_measurements.html">ehrapy.preprocessing.qc_lab_measurements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.explicit_impute.html">ehrapy.preprocessing.explicit_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.simple_impute.html">ehrapy.preprocessing.simple_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.knn_impute.html">ehrapy.preprocessing.knn_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.miss_forest_impute.html">ehrapy.preprocessing.miss_forest_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.soft_impute.html">ehrapy.preprocessing.soft_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.iterative_svd_impute.html">ehrapy.preprocessing.iterative_svd_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.matrix_factorization_impute.html">ehrapy.preprocessing.matrix_factorization_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.nuclear_norm_minimization_impute.html">ehrapy.preprocessing.nuclear_norm_minimization_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.mice_forest_impute.html">ehrapy.preprocessing.mice_forest_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.encode.html">ehrapy.preprocessing.encode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.undo_encoding.html">ehrapy.preprocessing.undo_encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.log_norm.html">ehrapy.preprocessing.log_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.maxabs_norm.html">ehrapy.preprocessing.maxabs_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.minmax_norm.html">ehrapy.preprocessing.minmax_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.power_norm.html">ehrapy.preprocessing.power_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.quantile_norm.html">ehrapy.preprocessing.quantile_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.robust_scale_norm.html">ehrapy.preprocessing.robust_scale_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.scale_norm.html">ehrapy.preprocessing.scale_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.sqrt_norm.html">ehrapy.preprocessing.sqrt_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.combat.html">ehrapy.preprocessing.combat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.neighbors.html">ehrapy.preprocessing.neighbors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.pca.html">ehrapy.tools.pca</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.tsne.html">ehrapy.tools.tsne</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.umap.html">ehrapy.tools.umap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.draw_graph.html">ehrapy.tools.draw_graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.diffmap.html">ehrapy.tools.diffmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.embedding_density.html">ehrapy.tools.embedding_density</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.leiden.html">ehrapy.tools.leiden</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.louvain.html">ehrapy.tools.louvain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.dendrogram.html">ehrapy.tools.dendrogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.dpt.html">ehrapy.tools.dpt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.paga.html">ehrapy.tools.paga</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.rank_features_groups.html">ehrapy.tools.rank_features_groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.filter_rank_features_groups.html">ehrapy.tools.filter_rank_features_groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.marker_feature_overlap.html">ehrapy.tools.marker_feature_overlap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.ingest.html">ehrapy.tools.ingest</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.Translator.html">ehrapy.tools.Translator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.HPOMapper.html">ehrapy.tools.HPOMapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.MedCAT.html">ehrapy.tools.MedCAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.mc.run_unsupervised_training.html">ehrapy.tools.mc.run_unsupervised_training</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.mc.annotate_text.html">ehrapy.tools.mc.annotate_text</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.mc.get_annotation_overview.html">ehrapy.tools.mc.get_annotation_overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.ols.html">ehrapy.tools.ols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.glm.html">ehrapy.tools.glm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.kmf.html">ehrapy.tools.kmf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.scatter.html">ehrapy.plot.scatter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.heatmap.html">ehrapy.plot.heatmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.dotplot.html">ehrapy.plot.dotplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.tracksplot.html">ehrapy.plot.tracksplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.violin.html">ehrapy.plot.violin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.stacked_violin.html">ehrapy.plot.stacked_violin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.matrixplot.html">ehrapy.plot.matrixplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.clustermap.html">ehrapy.plot.clustermap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.ranking.html">ehrapy.plot.ranking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.dendrogram.html">ehrapy.plot.dendrogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.qc_metrics.html">ehrapy.plot.qc_metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.pca.html">ehrapy.plot.pca</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.pca_loadings.html">ehrapy.plot.pca_loadings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.pca_variance_ratio.html">ehrapy.plot.pca_variance_ratio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.pca_overview.html">ehrapy.plot.pca_overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.tsne.html">ehrapy.plot.tsne</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.umap.html">ehrapy.plot.umap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.diffmap.html">ehrapy.plot.diffmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.draw_graph.html">ehrapy.plot.draw_graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.spatial.html">ehrapy.plot.spatial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.embedding.html">ehrapy.plot.embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.embedding_density.html">ehrapy.plot.embedding_density</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.dpt_groups_pseudotime.html">ehrapy.plot.dpt_groups_pseudotime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.dpt_timeseries.html">ehrapy.plot.dpt_timeseries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.paga.html">ehrapy.plot.paga</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.paga_path.html">ehrapy.plot.paga_path</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.paga_compare.html">ehrapy.plot.paga_compare</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups.html">ehrapy.plot.rank_features_groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_violin.html">ehrapy.plot.rank_features_groups_violin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_stacked_violin.html">ehrapy.plot.rank_features_groups_stacked_violin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_heatmap.html">ehrapy.plot.rank_features_groups_heatmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_dotplot.html">ehrapy.plot.rank_features_groups_dotplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_matrixplot.html">ehrapy.plot.rank_features_groups_matrixplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_tracksplot.html">ehrapy.plot.rank_features_groups_tracksplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.plot.ols.html">ehrapy.plot.ols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.plot.kmf.html">ehrapy.plot.kmf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/anndata/ehrapy.anndata.df_to_anndata.html">ehrapy.anndata.df_to_anndata</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/anndata/ehrapy.anndata.anndata_to_df.html">ehrapy.anndata.anndata_to_df</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/anndata/ehrapy.anndata.move_to_obs.html">ehrapy.anndata.move_to_obs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/anndata/ehrapy.anndata.move_to_x.html">ehrapy.anndata.move_to_x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/anndata/ehrapy.anndata.type_overview.html">ehrapy.anndata.type_overview</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/ehrapy_introduction.html">Introduction to ehrapy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/mimic_2_introduction.html">MIMIC-II IAC Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/mimic_2_fate.html">MIMIC-II Patient Fate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/mimic_2_survival_analysis.html">MIMIC-II Survival Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/diabetes_130.html">Diabetes 130 Vignette</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/medcat.html">Extracting from free text with MedCAT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributor Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../code_of_conduct.html">Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/theislab/ehrapy/discussions">Discussions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for ehrapy.preprocessing._data_imputation</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">anndata</span> <span class="kn">import</span> <span class="n">AnnData</span>
<span class="kn">from</span> <span class="nn">rich</span> <span class="kn">import</span> <span class="nb">print</span>
<span class="kn">from</span> <span class="nn">rich.progress</span> <span class="kn">import</span> <span class="n">Progress</span><span class="p">,</span> <span class="n">SpinnerColumn</span>
<span class="kn">from</span> <span class="nn">sklearn.experimental</span> <span class="kn">import</span> <span class="n">enable_iterative_imputer</span>  <span class="c1"># noqa: F401</span>
<span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">SimpleImputer</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">OrdinalEncoder</span>

<span class="kn">from</span> <span class="nn">ehrapy</span> <span class="kn">import</span> <span class="n">settings</span>
<span class="kn">from</span> <span class="nn">ehrapy.anndata.anndata_ext</span> <span class="kn">import</span> <span class="n">get_column_indices</span>
<span class="kn">from</span> <span class="nn">ehrapy.core.tool_available</span> <span class="kn">import</span> <span class="n">check_module_importable</span>


<div class="viewcode-block" id="explicit_impute"><a class="viewcode-back" href="../../../usage/imputation/ehrapy.preprocessing.explicit_impute.html#ehrapy.preprocessing.explicit_impute">[docs]</a><span class="k">def</span> <span class="nf">explicit_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">replacement</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]),</span>
    <span class="n">impute_empty_strings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Replaces all missing values in all or the specified columns with the passed value</span>

<span class="sd">    There are two scenarios to cover:</span>
<span class="sd">    1. Replace all missing values with the specified value.</span>
<span class="sd">    2. Replace all missing values in a subset of columns with a specified value per column.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object containing X to impute values in.</span>
<span class="sd">        replacement: Value to use as replacement or optionally keys to indicate which columns to replace with which value.</span>
<span class="sd">        impute_empty_strings: Whether to also impute empty strings.</span>
<span class="sd">        warning_threshold: Threshold of percentage of missing values to display a warning for (default: 30)</span>
<span class="sd">        copy: Whether to return a copy with the imputed data.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :class:`~anndata.AnnData` object with imputed X</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            adata = ep.dt.mimic_2(encode=True)</span>
<span class="sd">            ep.pp.explicit_impute(adata, replacement=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replacement</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replacement</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">),</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="o">=</span><span class="n">replacement</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="k">with</span> <span class="n">Progress</span><span class="p">(</span>
        <span class="s2">&quot;[progress.description]</span><span class="si">{task.description}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">SpinnerColumn</span><span class="p">(),</span>
        <span class="n">refresh_per_second</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s2">&quot;[blue]Running explicit imputation&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 1: Replace all missing values with the specified value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replacement</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">_replace_explicit</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">impute_empty_strings</span><span class="p">)</span>

        <span class="c1"># 2: Replace all missing values in a subset of columns with a specified value per column or a default value, when the column is not explicitly named</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replacement</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
                <span class="n">imputation_value</span> <span class="o">=</span> <span class="n">_extract_impute_value</span><span class="p">(</span><span class="n">replacement</span><span class="p">,</span> <span class="n">column_name</span><span class="p">)</span>
                <span class="c1"># only replace if an explicit value got passed or could be extracted from replacement</span>
                <span class="k">if</span> <span class="n">imputation_value</span><span class="p">:</span>
                    <span class="n">_replace_explicit</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[:,</span> <span class="n">idx</span> <span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">imputation_value</span><span class="p">,</span> <span class="n">impute_empty_strings</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[bold yellow]No replace value passed and found for var [not bold green]</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ReplacementDatatypeError</span><span class="p">(</span>  <span class="c1"># pragma: no cover</span>
                <span class="sa">f</span><span class="s2">&quot;Type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">replacement</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not a valid datatype for replacement parameter. Either use int, str or a dict!&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adata</span></div>


<span class="k">def</span> <span class="nf">_replace_explicit</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">replacement</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="n">impute_empty_strings</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Replace one column or whole X with a value where missing values are stored.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">impute_empty_strings</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">impute_conditions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">impute_conditions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">arr</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">impute_conditions</span><span class="p">]</span> <span class="o">=</span> <span class="n">replacement</span>


<span class="k">def</span> <span class="nf">_extract_impute_value</span><span class="p">(</span><span class="n">replacement</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">],</span> <span class="n">column_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Extract the replacement value for a given column in the :class:`~anndata.AnnData` object</span>

<span class="sd">    Returns:</span>
<span class="sd">        The value to replace missing values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># try to get a value for the specific column</span>
    <span class="n">imputation_value</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">imputation_value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">imputation_value</span>
    <span class="c1"># search for a default value in case no value was specified for that column</span>
    <span class="n">imputation_value</span> <span class="o">=</span> <span class="n">replacement</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">imputation_value</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="n">imputation_value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="c1"># ===================== Simple Imputation =========================</span>


<div class="viewcode-block" id="simple_impute"><a class="viewcode-back" href="../../../usage/imputation/ehrapy.preprocessing.simple_impute.html#ehrapy.preprocessing.simple_impute">[docs]</a><span class="k">def</span> <span class="nf">simple_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">strategy</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Impute AnnData object using mean/median/most frequent imputation. This works for numerical data only.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: The AnnData object to use mean Imputation on</span>
<span class="sd">        var_names: A list of var names indicating which columns to use mean imputation on (if None -&gt; all columns)</span>
<span class="sd">        strategy: Any of mean/median/most_frequent to indicate which strategy to use for simple imputation</span>
<span class="sd">        warning_threshold: Threshold of percentage of missing values to display a warning for (default: 30)</span>
<span class="sd">        copy: Whether to return a copy or act in place</span>

<span class="sd">    Returns:</span>
<span class="sd">        The imputed AnnData object</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            adata = ep.dt.mimic_2(encode=True)</span>
<span class="sd">            ep.pp.simple_impute(adata, strategy=&quot;median&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Progress</span><span class="p">(</span>
        <span class="s2">&quot;[progress.description]</span><span class="si">{task.description}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">SpinnerColumn</span><span class="p">(),</span>
        <span class="n">refresh_per_second</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[blue]Running simple imputation with </span><span class="si">{</span><span class="n">strategy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Imputation using median and mean strategy works with numerical data only</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">}:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_simple_impute</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">strategy</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ImputeStrategyNotAvailableError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Can only impute numerical data using </span><span class="si">{</span><span class="n">strategy</span><span class="si">}</span><span class="s2"> strategy. Try to restrict imputation&quot;</span>
                    <span class="s2">&quot;to certain columns using var_names parameter or use a different mode.&quot;</span>
                <span class="p">)</span>
        <span class="c1"># most_frequent imputation works with non numerical data as well</span>
        <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;most_frequent&quot;</span><span class="p">:</span>
            <span class="n">_simple_impute</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">strategy</span><span class="p">)</span>
        <span class="c1"># unknown simple imputation strategy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnknownImputeStrategyError</span><span class="p">(</span>  <span class="c1"># pragma: no cover</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown impute strategy </span><span class="si">{</span><span class="n">strategy</span><span class="si">}</span><span class="s2"> for simple Imputation. Choose any of mean, median or most_frequent.&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adata</span></div>


<span class="k">def</span> <span class="nf">_simple_impute</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span> <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strategy</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">imputer</span> <span class="o">=</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">)</span>
    <span class="c1"># impute a subset of columns</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
    <span class="c1"># impute all columns if None passed</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>


<span class="c1"># ===================== KNN Imputation =========================</span>


<div class="viewcode-block" id="knn_impute"><a class="viewcode-back" href="../../../usage/imputation/ehrapy.preprocessing.knn_impute.html#ehrapy.preprocessing.knn_impute">[docs]</a><span class="k">def</span> <span class="nf">knn_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_neighbours</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Impute data using the KNN-Imputer.</span>

<span class="sd">    When using KNN Imputation with mixed data (non-numerical and numerical), encoding using ordinal encoding is required</span>
<span class="sd">    since KNN Imputation can only work on numerical data. The encoding itself is just a utility and will be undone once</span>
<span class="sd">    imputation ran successfully.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: The AnnData object to use KNN Imputation on</span>
<span class="sd">        var_names: A list of var names indicating which columns to use median imputation on (if None -&gt; all columns)</span>
<span class="sd">        n_neighbours: Number of neighbours to consider while imputing (default: 5)</span>
<span class="sd">        warning_threshold: Threshold of percentage of missing values to display a warning for (default: 30)</span>
<span class="sd">        copy: Whether to return a copy or act in place</span>

<span class="sd">    Returns:</span>
<span class="sd">        The imputed (but unencoded) AnnData object</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            adata = ep.dt.mimic_2(encode=True)</span>
<span class="sd">            ep.pp.knn_impute(adata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_module_importable</span><span class="p">(</span><span class="s2">&quot;sklearnex&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="kn">from</span> <span class="nn">sklearnex</span> <span class="kn">import</span> <span class="n">patch_sklearn</span><span class="p">,</span> <span class="n">unpatch_sklearn</span>

        <span class="n">patch_sklearn</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;[bold yellow]scikit-learn-intelex is not available. Install via [blue]pip install scikit-learn-intelex [yellow] for faster imputations.&quot;</span>
        <span class="p">)</span>

    <span class="k">with</span> <span class="n">Progress</span><span class="p">(</span>
        <span class="s2">&quot;[progress.description]</span><span class="si">{task.description}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">SpinnerColumn</span><span class="p">(),</span>
        <span class="n">refresh_per_second</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s2">&quot;[blue]Running KNN imputation&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># numerical only data needs no encoding since KNN Imputation can be applied directly</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">_knn_impute</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">n_neighbours</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ordinal encoding is used since non-numerical data can not be imputed using KNN Imputation</span>
            <span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
            <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;non_numerical_columns&quot;</span><span class="p">])</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
            <span class="c1"># impute the data using KNN imputation</span>
            <span class="n">_knn_impute</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">n_neighbours</span><span class="p">)</span>
            <span class="c1"># imputing on encoded columns might result in float numbers; those can not be decoded</span>
            <span class="c1"># cast them to int to ensure they can be decoded</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="c1"># knn imputer transforms X dtype to numerical (encoded), but object is needed for decoding</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
            <span class="c1"># decode ordinal encoding to obtain imputed original data</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">check_module_importable</span><span class="p">(</span><span class="s2">&quot;sklearnex&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">unpatch_sklearn</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adata</span></div>


<span class="k">def</span> <span class="nf">_knn_impute</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span> <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n_neighbours</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Utility function to impute data using KNN-Imputer&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">KNNImputer</span>

    <span class="n">imputer</span> <span class="o">=</span> <span class="n">KNNImputer</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbours</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
        <span class="c1"># this is required since X dtype has to be numerical in order to correctly round floats</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>


<span class="c1"># ======================  MissForest Impuation =======================</span>


<div class="viewcode-block" id="miss_forest_impute"><a class="viewcode-back" href="../../../usage/imputation/ehrapy.preprocessing.miss_forest_impute.html#ehrapy.preprocessing.miss_forest_impute">[docs]</a><span class="k">def</span> <span class="nf">miss_forest_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">num_initial_strategy</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Impute data using the MissForest strategy.</span>

<span class="sd">    See https://academic.oup.com/bioinformatics/article/28/1/112/219101.</span>
<span class="sd">    This requires the computation of which columns in X contain numerical only (including NaNs) and which contain non-numerical data.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: The AnnData object to use MissForest Imputation on.</span>
<span class="sd">        var_names: List of columns to impute or a dict with two keys (&#39;numerical&#39; and &#39;non_numerical&#39;) indicating which var</span>
<span class="sd">                   contain mixed data and which numerical data only.</span>
<span class="sd">        num_initial_strategy: The initial strategy to replace all missing values with (default: &#39;mean&#39;).</span>
<span class="sd">        max_iter: The maximum number of iterations if the stop criterion has not been met yet.</span>
<span class="sd">        n_estimators: The number of trees to fit for every missing variable. Has a big effect on the run time.</span>
<span class="sd">                      Decrease for faster computations (default: 100).</span>
<span class="sd">        random_state: The random seed for the initialization.</span>
<span class="sd">        warning_threshold: Threshold of percentage of missing values to display a warning for (default: 30).</span>
<span class="sd">        copy: Whether to return a copy or act in place.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The imputed (but unencoded) AnnData object.</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            adata = ep.dt.mimic_2(encode=True)</span>
<span class="sd">            ep.pp.miss_forest_impute(adata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">var_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">),</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check_module_importable</span><span class="p">(</span><span class="s2">&quot;sklearnex&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="kn">from</span> <span class="nn">sklearnex</span> <span class="kn">import</span> <span class="n">patch_sklearn</span><span class="p">,</span> <span class="n">unpatch_sklearn</span>

        <span class="n">patch_sklearn</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;[bold yellow]scikit-learn-intelex is not available. Install via [blue]pip install scikit-learn-intelex [yellow] for faster imputations.&quot;</span>
        <span class="p">)</span>

    <span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">ExtraTreesRegressor</span><span class="p">,</span> <span class="n">RandomForestClassifier</span>
    <span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">IterativeImputer</span>

    <span class="k">with</span> <span class="n">Progress</span><span class="p">(</span>
        <span class="s2">&quot;[progress.description]</span><span class="si">{task.description}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">SpinnerColumn</span><span class="p">(),</span>
        <span class="n">refresh_per_second</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s2">&quot;[blue]Running MissForest imputation&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[bold yellow]The number of jobs is only 1. To decrease the runtime set [blue]ep.settings.n_jobs=-1.&quot;</span><span class="p">)</span>

        <span class="n">imp_num</span> <span class="o">=</span> <span class="n">IterativeImputer</span><span class="p">(</span>
            <span class="n">estimator</span><span class="o">=</span><span class="n">ExtraTreesRegressor</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="n">n_estimators</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">),</span>
            <span class="n">initial_strategy</span><span class="o">=</span><span class="n">num_initial_strategy</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># initial strategy here will not be parametrized since only most_frequent will be applied to non numerical data</span>
        <span class="n">imp_cat</span> <span class="o">=</span> <span class="n">IterativeImputer</span><span class="p">(</span>
            <span class="n">estimator</span><span class="o">=</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="n">n_estimators</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">settings</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">),</span>
            <span class="n">initial_strategy</span><span class="o">=</span><span class="s2">&quot;most_frequent&quot;</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">var_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">var_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">imp_num</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">var_indices</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="n">var_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var_names</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">non_num_vars</span> <span class="o">=</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;non_numerical&quot;</span><span class="p">]</span>
                    <span class="n">num_vars</span> <span class="o">=</span> <span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;numerical&quot;</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="k">raise</span> <span class="n">MissForestKeyError</span><span class="p">(</span>
                        <span class="s2">&quot;One or both of your keys provided for var_names are unknown. Only &quot;</span>
                        <span class="s2">&quot;numerical and non_numerical are available!&quot;</span>
                    <span class="p">)</span>
                <span class="n">non_num_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">non_num_vars</span><span class="p">)</span>
                <span class="n">num_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">)</span>

            <span class="c1"># infer non numerical and numerical indices automatically</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">non_num_indices_set</span> <span class="o">=</span> <span class="n">_get_non_numerical_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
                <span class="n">num_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">non_num_indices_set</span><span class="p">]</span>
                <span class="n">non_num_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">non_num_indices_set</span><span class="p">)</span>

            <span class="c1"># encode all non numerical columns</span>
            <span class="k">if</span> <span class="n">non_num_indices</span><span class="p">:</span>
                <span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
                <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">non_num_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">non_num_indices</span><span class="p">])</span>
            <span class="c1"># this step is the most expensive one and might extremely slow down the impute process</span>
            <span class="k">if</span> <span class="n">num_indices</span><span class="p">:</span>
                <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">num_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">imp_num</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">num_indices</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">non_num_indices</span><span class="p">:</span>
                <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">non_num_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">imp_cat</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">non_num_indices</span><span class="p">])</span>
                <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">non_num_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">non_num_indices</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">check_module_importable</span><span class="p">(</span><span class="s2">&quot;sklearnex&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">unpatch_sklearn</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adata</span></div>


<span class="c1"># ===================== SoftImpute =========================</span>


<div class="viewcode-block" id="soft_impute"><a class="viewcode-back" href="../../../usage/imputation/ehrapy.preprocessing.soft_impute.html#ehrapy.preprocessing.soft_impute">[docs]</a><span class="k">def</span> <span class="nf">soft_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">shrinkage_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">convergence_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="n">max_iters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">max_rank</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_power_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">init_fill_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;zero&quot;</span><span class="p">,</span>
    <span class="n">min_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">normalizer</span><span class="p">:</span> <span class="nb">object</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Impute data using the SoftImpute.</span>

<span class="sd">    See https://github.com/iskandr/fancyimpute/blob/master/fancyimpute/soft_impute.py</span>
<span class="sd">    Matrix completion by iterative soft thresholding of SVD decompositions.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: The AnnData object to use SoftImpute on.</span>
<span class="sd">        var_names: A list of var names indicating which columns to impute (if None -&gt; all columns).</span>
<span class="sd">        copy: Whether to return a copy or act in place.</span>
<span class="sd">        warning_threshold: Threshold of percentage of missing values to display a warning for (default: 30).</span>
<span class="sd">        shrinkage_value : Value by which we shrink singular values on each iteration. If omitted then the default value will be the maximum singular value of the initialized matrix (zeros for missing values) divided by 50.</span>
<span class="sd">        convergence_threshold : Minimum ration difference between iterations (as a fraction of the Frobenius norm of the current solution) before stopping.</span>
<span class="sd">        max_iters: Maximum number of SVD iterations.</span>
<span class="sd">        max_rank: Perform a truncated SVD on each iteration with this value as its rank.</span>
<span class="sd">        n_power_iterations: Number of power iterations to perform with randomized SVD.</span>
<span class="sd">        init_fill_method: How to initialize missing values of data matrix, default is to fill them with zeros.</span>
<span class="sd">        min_value: Smallest allowable value in the solution.</span>
<span class="sd">        max_value: Largest allowable value in the solution.</span>
<span class="sd">        normalizer: Any object (such as BiScaler) with fit() and transform() methods.</span>
<span class="sd">        verbose: Print debugging info.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The imputed AnnData object</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            adata = ep.dt.mimic_2(encoded=True)</span>
<span class="sd">            ep.pp.soft_impute(adata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Progress</span><span class="p">(</span>
        <span class="s2">&quot;[progress.description]</span><span class="si">{task.description}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">SpinnerColumn</span><span class="p">(),</span>
        <span class="n">refresh_per_second</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s2">&quot;[blue]Running SoftImpute&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">_soft_impute</span><span class="p">(</span>
                <span class="n">adata</span><span class="p">,</span>
                <span class="n">var_names</span><span class="p">,</span>
                <span class="n">shrinkage_value</span><span class="p">,</span>
                <span class="n">convergence_threshold</span><span class="p">,</span>
                <span class="n">max_iters</span><span class="p">,</span>
                <span class="n">max_rank</span><span class="p">,</span>
                <span class="n">n_power_iterations</span><span class="p">,</span>
                <span class="n">init_fill_method</span><span class="p">,</span>
                <span class="n">min_value</span><span class="p">,</span>
                <span class="n">max_value</span><span class="p">,</span>
                <span class="n">normalizer</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ordinal encoding is used since non-numerical data can not be imputed using SoftImpute</span>
            <span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
            <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;non_numerical_columns&quot;</span><span class="p">])</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
            <span class="c1"># impute the data using SoftImpute</span>
            <span class="n">_soft_impute</span><span class="p">(</span>
                <span class="n">adata</span><span class="p">,</span>
                <span class="n">var_names</span><span class="p">,</span>
                <span class="n">shrinkage_value</span><span class="p">,</span>
                <span class="n">convergence_threshold</span><span class="p">,</span>
                <span class="n">max_iters</span><span class="p">,</span>
                <span class="n">max_rank</span><span class="p">,</span>
                <span class="n">n_power_iterations</span><span class="p">,</span>
                <span class="n">init_fill_method</span><span class="p">,</span>
                <span class="n">min_value</span><span class="p">,</span>
                <span class="n">max_value</span><span class="p">,</span>
                <span class="n">normalizer</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
            <span class="c1"># decode ordinal encoding to obtain imputed original data</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">adata</span></div>


<span class="k">def</span> <span class="nf">_soft_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shrinkage_value</span><span class="p">,</span>
    <span class="n">convergence_threshold</span><span class="p">,</span>
    <span class="n">max_iters</span><span class="p">,</span>
    <span class="n">max_rank</span><span class="p">,</span>
    <span class="n">n_power_iterations</span><span class="p">,</span>
    <span class="n">init_fill_method</span><span class="p">,</span>
    <span class="n">min_value</span><span class="p">,</span>
    <span class="n">max_value</span><span class="p">,</span>
    <span class="n">normalizer</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Utility function to impute data using SoftImpute&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">fancyimpute</span> <span class="kn">import</span> <span class="n">SoftImpute</span>

    <span class="n">imputer</span> <span class="o">=</span> <span class="n">SoftImpute</span><span class="p">(</span>
        <span class="n">shrinkage_value</span><span class="p">,</span>
        <span class="n">convergence_threshold</span><span class="p">,</span>
        <span class="n">max_iters</span><span class="p">,</span>
        <span class="n">max_rank</span><span class="p">,</span>
        <span class="n">n_power_iterations</span><span class="p">,</span>
        <span class="n">init_fill_method</span><span class="p">,</span>
        <span class="n">min_value</span><span class="p">,</span>
        <span class="n">max_value</span><span class="p">,</span>
        <span class="n">normalizer</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>


<span class="c1"># ===================== IterativeSVD =========================</span>


<div class="viewcode-block" id="iterative_svd_impute"><a class="viewcode-back" href="../../../usage/imputation/ehrapy.preprocessing.iterative_svd_impute.html#ehrapy.preprocessing.iterative_svd_impute">[docs]</a><span class="k">def</span> <span class="nf">iterative_svd_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">convergence_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.00001</span><span class="p">,</span>
    <span class="n">max_iters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="n">gradual_rank_increase</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">svd_algorithm</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;arpack&quot;</span><span class="p">,</span>
    <span class="n">init_fill_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;zero&quot;</span><span class="p">,</span>
    <span class="n">min_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Impute data using the IterativeSVD.</span>

<span class="sd">    See https://github.com/iskandr/fancyimpute/blob/master/fancyimpute/iterative_svd.py</span>
<span class="sd">    Matrix completion by iterative low-rank SVD decomposition.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: The AnnData object to use IterativeSVD on.</span>
<span class="sd">        var_names: A list of var names indicating which columns to impute (if None -&gt; all columns).</span>
<span class="sd">        copy: Whether to return a copy or act in place.</span>
<span class="sd">        warning_threshold: Threshold of percentage of missing values to display a warning for (default: 30).</span>

<span class="sd">    Returns:</span>
<span class="sd">        The imputed AnnData object</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            adata = ep.dt.mimic_2(encoded=True)</span>
<span class="sd">            ep.pp.iterative_svd_impute(adata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Progress</span><span class="p">(</span>
        <span class="s2">&quot;[progress.description]</span><span class="si">{task.description}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">SpinnerColumn</span><span class="p">(),</span>
        <span class="n">refresh_per_second</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s2">&quot;[blue]Running IterativeSVD&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">_iterative_svd_impute</span><span class="p">(</span>
                <span class="n">adata</span><span class="p">,</span>
                <span class="n">var_names</span><span class="p">,</span>
                <span class="n">rank</span><span class="p">,</span>
                <span class="n">convergence_threshold</span><span class="p">,</span>
                <span class="n">max_iters</span><span class="p">,</span>
                <span class="n">gradual_rank_increase</span><span class="p">,</span>
                <span class="n">svd_algorithm</span><span class="p">,</span>
                <span class="n">init_fill_method</span><span class="p">,</span>
                <span class="n">min_value</span><span class="p">,</span>
                <span class="n">max_value</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ordinal encoding is used since non-numerical data can not be imputed using IterativeSVD</span>
            <span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
            <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;non_numerical_columns&quot;</span><span class="p">])</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
            <span class="c1"># impute the data using IterativeSVD</span>
            <span class="n">_iterative_svd_impute</span><span class="p">(</span>
                <span class="n">adata</span><span class="p">,</span>
                <span class="n">var_names</span><span class="p">,</span>
                <span class="n">rank</span><span class="p">,</span>
                <span class="n">convergence_threshold</span><span class="p">,</span>
                <span class="n">max_iters</span><span class="p">,</span>
                <span class="n">gradual_rank_increase</span><span class="p">,</span>
                <span class="n">svd_algorithm</span><span class="p">,</span>
                <span class="n">init_fill_method</span><span class="p">,</span>
                <span class="n">min_value</span><span class="p">,</span>
                <span class="n">max_value</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
            <span class="c1"># decode ordinal encoding to obtain imputed original data</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">adata</span></div>


<span class="k">def</span> <span class="nf">_iterative_svd_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">,</span>
    <span class="n">convergence_threshold</span><span class="p">,</span>
    <span class="n">max_iters</span><span class="p">,</span>
    <span class="n">gradual_rank_increase</span><span class="p">,</span>
    <span class="n">svd_algorithm</span><span class="p">,</span>
    <span class="n">init_fill_method</span><span class="p">,</span>
    <span class="n">min_value</span><span class="p">,</span>
    <span class="n">max_value</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Utility function to impute data using IterativeSVD&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">fancyimpute</span> <span class="kn">import</span> <span class="n">IterativeSVD</span>

    <span class="n">imputer</span> <span class="o">=</span> <span class="n">IterativeSVD</span><span class="p">(</span>
        <span class="n">rank</span><span class="p">,</span>
        <span class="n">convergence_threshold</span><span class="p">,</span>
        <span class="n">max_iters</span><span class="p">,</span>
        <span class="n">gradual_rank_increase</span><span class="p">,</span>
        <span class="n">svd_algorithm</span><span class="p">,</span>
        <span class="n">init_fill_method</span><span class="p">,</span>
        <span class="n">min_value</span><span class="p">,</span>
        <span class="n">max_value</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>


<span class="c1"># ===================== MatrixFactorization =========================</span>


<div class="viewcode-block" id="matrix_factorization_impute"><a class="viewcode-back" href="../../../usage/imputation/ehrapy.preprocessing.matrix_factorization_impute.html#ehrapy.preprocessing.matrix_factorization_impute">[docs]</a><span class="k">def</span> <span class="nf">matrix_factorization_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="n">learning_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">max_iters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
    <span class="n">shrinkage_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">min_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Impute data using the MatrixFactorization.</span>

<span class="sd">    See https://github.com/iskandr/fancyimpute/blob/master/fancyimpute/matrix_factorization.py</span>
<span class="sd">    Train a matrix factorization model to predict empty entries in a matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: The AnnData object to use MatrixFactorization on.</span>
<span class="sd">        var_names: A list of var names indicating which columns to impute (if None -&gt; all columns).</span>
<span class="sd">        copy: Whether to return a copy or act in place.</span>
<span class="sd">        warning_threshold: Threshold of percentage of missing values to display a warning for (default: 30).</span>
<span class="sd">        rank: Number of latent factors to use in matrix factorization model</span>
<span class="sd">        learning_rate: Learning rate for optimizer</span>
<span class="sd">        max_iters: Number of max_iters to train for</span>
<span class="sd">        shrinkage_value: Regularization term for sgd penalty</span>
<span class="sd">        min_value: Smallest possible imputed value</span>
<span class="sd">        max_value: Largest possible imputed value</span>
<span class="sd">        verbose: Whether or not to printout training progress</span>

<span class="sd">    Returns:</span>
<span class="sd">        The imputed AnnData object</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            adata = ep.dt.mimic_2(encoded=True)</span>
<span class="sd">            ep.pp.matrix_factorization_impute(adata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Progress</span><span class="p">(</span>
        <span class="s2">&quot;[progress.description]</span><span class="si">{task.description}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">SpinnerColumn</span><span class="p">(),</span>
        <span class="n">refresh_per_second</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s2">&quot;[blue]Running MatrixFactorization&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">_matrix_factorization_impute</span><span class="p">(</span>
                <span class="n">adata</span><span class="p">,</span>
                <span class="n">var_names</span><span class="p">,</span>
                <span class="n">rank</span><span class="p">,</span>
                <span class="n">learning_rate</span><span class="p">,</span>
                <span class="n">max_iters</span><span class="p">,</span>
                <span class="n">shrinkage_value</span><span class="p">,</span>
                <span class="n">min_value</span><span class="p">,</span>
                <span class="n">max_value</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ordinal encoding is used since non-numerical data can not be imputed using MatrixFactorization</span>
            <span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
            <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;non_numerical_columns&quot;</span><span class="p">])</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
            <span class="c1"># impute the data using MatrixFactorization</span>
            <span class="n">_matrix_factorization_impute</span><span class="p">(</span>
                <span class="n">adata</span><span class="p">,</span>
                <span class="n">var_names</span><span class="p">,</span>
                <span class="n">rank</span><span class="p">,</span>
                <span class="n">learning_rate</span><span class="p">,</span>
                <span class="n">max_iters</span><span class="p">,</span>
                <span class="n">shrinkage_value</span><span class="p">,</span>
                <span class="n">min_value</span><span class="p">,</span>
                <span class="n">max_value</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
            <span class="c1"># decode ordinal encoding to obtain imputed original data</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">adata</span></div>


<span class="k">def</span> <span class="nf">_matrix_factorization_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">,</span>
    <span class="n">learning_rate</span><span class="p">,</span>
    <span class="n">max_iters</span><span class="p">,</span>
    <span class="n">shrinkage_value</span><span class="p">,</span>
    <span class="n">min_value</span><span class="p">,</span>
    <span class="n">max_value</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Utility function to impute data using MatrixFactorization&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">fancyimpute</span> <span class="kn">import</span> <span class="n">MatrixFactorization</span>

    <span class="n">imputer</span> <span class="o">=</span> <span class="n">MatrixFactorization</span><span class="p">(</span>
        <span class="n">rank</span><span class="p">,</span>
        <span class="n">learning_rate</span><span class="p">,</span>
        <span class="n">max_iters</span><span class="p">,</span>
        <span class="n">shrinkage_value</span><span class="p">,</span>
        <span class="n">min_value</span><span class="p">,</span>
        <span class="n">max_value</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>


<span class="c1"># ===================== NuclearNormMinimization =========================</span>


<div class="viewcode-block" id="nuclear_norm_minimization_impute"><a class="viewcode-back" href="../../../usage/imputation/ehrapy.preprocessing.nuclear_norm_minimization_impute.html#ehrapy.preprocessing.nuclear_norm_minimization_impute">[docs]</a><span class="k">def</span> <span class="nf">nuclear_norm_minimization_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">require_symmetric_solution</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">min_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">error_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
    <span class="n">max_iters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50000</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Impute data using the NuclearNormMinimization.</span>

<span class="sd">    See https://github.com/iskandr/fancyimpute/blob/master/fancyimpute/nuclear_norm_minimization.py</span>
<span class="sd">    Simple implementation of &quot;Exact Matrix Completion via Convex Optimization&quot; by Emmanuel Candes and Benjamin Recht using cvxpy.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: The AnnData object to use NuclearNormMinimization on.</span>
<span class="sd">        var_names: A list of var names indicating which columns to impute (if None -&gt; all columns).</span>
<span class="sd">        copy: Whether to return a copy or act in place.</span>
<span class="sd">        warning_threshold: Threshold of percentage of missing values to display a warning for (default: 30).</span>
<span class="sd">        require_symmetric_solution: Add symmetry constraint to convex problem</span>
<span class="sd">        min_value: Smallest possible imputed value</span>
<span class="sd">        max_value: Largest possible imputed value</span>
<span class="sd">        error_tolerance: Degree of error allowed on reconstructed values. If omitted then defaults to 0.0001</span>
<span class="sd">        max_iters: Maximum number of iterations for the convex solver</span>
<span class="sd">        verbose: Print debug info</span>

<span class="sd">    Returns:</span>
<span class="sd">        The imputed AnnData object</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            adata = ep.dt.mimic_2(encoded=True)</span>
<span class="sd">            ep.pp.nuclear_norm_minimization_impute(adata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Progress</span><span class="p">(</span>
        <span class="s2">&quot;[progress.description]</span><span class="si">{task.description}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">SpinnerColumn</span><span class="p">(),</span>
        <span class="n">refresh_per_second</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s2">&quot;[blue]Running NuclearNormMinimization&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">_nuclear_norm_minimization_impute</span><span class="p">(</span>
                <span class="n">adata</span><span class="p">,</span>
                <span class="n">var_names</span><span class="p">,</span>
                <span class="n">require_symmetric_solution</span><span class="p">,</span>
                <span class="n">min_value</span><span class="p">,</span>
                <span class="n">max_value</span><span class="p">,</span>
                <span class="n">error_tolerance</span><span class="p">,</span>
                <span class="n">max_iters</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ordinal encoding is used since non-numerical data can not be imputed using NuclearNormMinimization</span>
            <span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
            <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;non_numerical_columns&quot;</span><span class="p">])</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
            <span class="c1"># impute the data using NuclearNormMinimization</span>
            <span class="n">_nuclear_norm_minimization_impute</span><span class="p">(</span>
                <span class="n">adata</span><span class="p">,</span>
                <span class="n">var_names</span><span class="p">,</span>
                <span class="n">require_symmetric_solution</span><span class="p">,</span>
                <span class="n">min_value</span><span class="p">,</span>
                <span class="n">max_value</span><span class="p">,</span>
                <span class="n">error_tolerance</span><span class="p">,</span>
                <span class="n">max_iters</span><span class="p">,</span>
                <span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
            <span class="c1"># decode ordinal encoding to obtain imputed original data</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">adata</span></div>


<span class="k">def</span> <span class="nf">_nuclear_norm_minimization_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">,</span>
    <span class="n">require_symmetric_solution</span><span class="p">,</span>
    <span class="n">min_value</span><span class="p">,</span>
    <span class="n">max_value</span><span class="p">,</span>
    <span class="n">error_tolerance</span><span class="p">,</span>
    <span class="n">max_iters</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Utility function to impute data using NuclearNormMinimization&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">fancyimpute</span> <span class="kn">import</span> <span class="n">NuclearNormMinimization</span>

    <span class="n">imputer</span> <span class="o">=</span> <span class="n">NuclearNormMinimization</span><span class="p">(</span>
        <span class="n">require_symmetric_solution</span><span class="p">,</span>
        <span class="n">min_value</span><span class="p">,</span>
        <span class="n">max_value</span><span class="p">,</span>
        <span class="n">error_tolerance</span><span class="p">,</span>
        <span class="n">max_iters</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">)</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>


<span class="c1"># ===================== miceforest =========================</span>


<div class="viewcode-block" id="mice_forest_impute"><a class="viewcode-back" href="../../../usage/imputation/ehrapy.preprocessing.mice_forest_impute.html#ehrapy.preprocessing.mice_forest_impute">[docs]</a><span class="k">def</span> <span class="nf">mice_forest_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">save_all_iterations</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">variable_parameters</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Impute data using the miceforest.</span>

<span class="sd">    See https://github.com/AnotherSamWilson/miceforest</span>
<span class="sd">    Fast, memory efficient Multiple Imputation by Chained Equations (MICE) with lightgbm.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: The AnnData object to use miceforest on.</span>
<span class="sd">        var_names: A list of var names indicating which columns to impute (if None -&gt; all columns).</span>
<span class="sd">        copy: Whether to return a copy or act in place.</span>
<span class="sd">        warning_threshold: Threshold of percentage of missing values to display a warning for (default: 30).</span>
<span class="sd">        save_all_iterations: Save all the imputation values from all iterations, or just the latest. Saving all iterations allows for additional plotting, but may take more memory.</span>
<span class="sd">        random_state: The random_state ensures script reproducibility. It only ensures reproducible results if the same script is called multiple times. It does not guarantee reproducible results at the record level, if a record is imputed multiple different times. If reproducible record-results are desired, a seed must be passed for each record in the random_seed_array parameter.</span>
<span class="sd">        inplace: Using inplace=False returns a copy of the completed data. Since the raw data is already stored in kernel.working_data, you can set inplace=True to complete the data without returning a copy.</span>
<span class="sd">        iterations: The number of iterations to run.</span>
<span class="sd">        variable_parameters: Model parameters can be specified by variable here. Keys should be variable names or indices, and values should be a dict of parameter which should apply to that variable only.</span>
<span class="sd">        verbose: Should information about the process be printed.</span>
<span class="sd">    Returns:</span>
<span class="sd">        The imputed AnnData object</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            adata = ep.dt.mimic_2(encoded=True)</span>
<span class="sd">            ep.pp.miceforest_impute(adata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">warning_threshold</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">Progress</span><span class="p">(</span>
        <span class="s2">&quot;[progress.description]</span><span class="si">{task.description}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">SpinnerColumn</span><span class="p">(),</span>
        <span class="n">refresh_per_second</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">progress</span><span class="p">:</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s2">&quot;[blue]Running miceforest&quot;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
            <span class="n">_miceforest_impute</span><span class="p">(</span>
                <span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">save_all_iterations</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">variable_parameters</span><span class="p">,</span> <span class="n">verbose</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ordinal encoding is used since non-numerical data can not be imputed using miceforest</span>
            <span class="n">enc</span> <span class="o">=</span> <span class="n">OrdinalEncoder</span><span class="p">()</span>
            <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s2">&quot;non_numerical_columns&quot;</span><span class="p">])</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>
            <span class="c1"># impute the data using miceforest</span>
            <span class="n">_miceforest_impute</span><span class="p">(</span>
                <span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">save_all_iterations</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">variable_parameters</span><span class="p">,</span> <span class="n">verbose</span>
            <span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
            <span class="c1"># decode ordinal encoding to obtain imputed original data</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">enc</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">adata</span></div>


<span class="k">def</span> <span class="nf">_miceforest_impute</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">save_all_iterations</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">variable_parameters</span><span class="p">,</span> <span class="n">verbose</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Utility function to impute data using miceforest&quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">miceforest</span> <span class="k">as</span> <span class="nn">mf</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="n">get_column_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">var_names</span><span class="p">)</span>

        <span class="c1"># Create kernel.</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">ImputationKernel</span><span class="p">(</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">],</span> <span class="n">datasets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">save_all_iterations</span><span class="o">=</span><span class="n">save_all_iterations</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
        <span class="p">)</span>

        <span class="n">kernel</span><span class="o">.</span><span class="n">mice</span><span class="p">(</span><span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="n">variable_parameters</span><span class="o">=</span><span class="n">variable_parameters</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">[::,</span> <span class="n">column_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">complete_data</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Create kernel.</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">ImputationKernel</span><span class="p">(</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">datasets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">save_all_iterations</span><span class="o">=</span><span class="n">save_all_iterations</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
        <span class="p">)</span>

        <span class="n">kernel</span><span class="o">.</span><span class="n">mice</span><span class="p">(</span><span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span> <span class="n">variable_parameters</span><span class="o">=</span><span class="n">variable_parameters</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">complete_data</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_warn_imputation_threshold</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span> <span class="n">var_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Warns the user if the more than $threshold percent had to be imputed.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: The AnnData object to check</span>
<span class="sd">        var_names: The var names which were imputed.</span>
<span class="sd">        threshold: A percentage value from 0 to 100 used as minimum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;missing_values_pct&quot;</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[bold yellow]Quality control metrics missing. Calculating...&quot;</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">ehrapy.preprocessing</span> <span class="kn">import</span> <span class="n">qc_metrics</span>

        <span class="n">qc_metrics</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
    <span class="n">used_var_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">var_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span><span class="n">var_names</span><span class="p">)</span>

    <span class="n">thresholded_var_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;missing_values_pct&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">used_var_names</span><span class="p">)</span>

    <span class="n">var_name_to_pct</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">thresholded_var_names</span><span class="p">:</span>
        <span class="n">var_name_to_pct</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s2">&quot;missing_values_pct&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;[bold yellow]Feature [blue]</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> [yellow]had more than [blue]</span><span class="si">{</span><span class="n">var_name_to_pct</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% [yellow]missing values!&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">var_name_to_pct</span>


<span class="k">def</span> <span class="nf">_get_non_numerical_column_indices</span><span class="p">(</span><span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return indices of columns, that contain at least one non numerical value that is not &quot;Nan&quot;.&quot;&quot;&quot;</span>
    <span class="n">is_numeric_numpy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_is_float_or_nan</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="nb">bool</span><span class="p">])</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">is_numeric_numpy</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">column_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">non_num_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">column_indices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">non_num_indices</span>


<span class="k">def</span> <span class="nf">_is_float_or_nan</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Check whether a given item is a float or np.nan&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">MissingImputeValuesError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ReplacementDatatypeError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">MissingImputationValue</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ImputeStrategyNotAvailableError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">UnknownImputeStrategyError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">MissForestKeyError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2021, Lukas Heumos, Theislab
            </div>
            Made with 
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>