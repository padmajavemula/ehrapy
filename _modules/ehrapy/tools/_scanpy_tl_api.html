<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <meta name="generator" content="sphinx-5.1.1, furo 2022.06.21"/>
        <title>ehrapy.tools._scanpy_tl_api - ehrapy</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=40978830699223671f4072448e654b5958f38b89" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/override.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/sphinx_gallery.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --color-brand-primary: #003262;
  --color-brand-content: #003262;
  --admonition-font-size: var(--font-size-normal);
  --admonition-title-font-size: var(--font-size-normal);
  --code-font-size: var(--font-size--small);
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">ehrapy</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand centered" href="../../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../../_static/ehrapy_pure.png" alt="Logo"/>
  </div>
  
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../usage/usage.html">Usage</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/io/ehrapy.io.read_csv.html">ehrapy.io.read_csv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/io/ehrapy.io.read_h5ad.html">ehrapy.io.read_h5ad</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/io/ehrapy.io.read_pdf.html">ehrapy.io.read_pdf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/io/ehrapy.io.write.html">ehrapy.io.write</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.mimic_2.html">ehrapy.data.mimic_2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.mimic_3_demo.html">ehrapy.data.mimic_3_demo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.diabetes_130.html">ehrapy.data.diabetes_130</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.heart_failure.html">ehrapy.data.heart_failure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.chronic_kidney_disease.html">ehrapy.data.chronic_kidney_disease</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.breast_tissue.html">ehrapy.data.breast_tissue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.cervical_cancer_risk_factors.html">ehrapy.data.cervical_cancer_risk_factors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.dermatology.html">ehrapy.data.dermatology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.echocardiogram.html">ehrapy.data.echocardiogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.heart_disease.html">ehrapy.data.heart_disease</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.hepatitis.html">ehrapy.data.hepatitis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.statlog_heart.html">ehrapy.data.statlog_heart</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.thyroid.html">ehrapy.data.thyroid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.breast_cancer_coimbra.html">ehrapy.data.breast_cancer_coimbra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.parkinson_dataset_with_replicated_acoustic_features.html">ehrapy.data.parkinson_dataset_with_replicated_acoustic_features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.parkinsons.html">ehrapy.data.parkinsons</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.parkinsons_disease_classification.html">ehrapy.data.parkinsons_disease_classification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/data/ehrapy.data.parkinsons_telemonitoring.html">ehrapy.data.parkinsons_telemonitoring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.pca.html">ehrapy.preprocessing.pca</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.regress_out.html">ehrapy.preprocessing.regress_out</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.subsample.html">ehrapy.preprocessing.subsample</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.highly_variable_features.html">ehrapy.preprocessing.highly_variable_features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.qc_metrics.html">ehrapy.preprocessing.qc_metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.qc_lab_measurements.html">ehrapy.preprocessing.qc_lab_measurements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.explicit_impute.html">ehrapy.preprocessing.explicit_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.simple_impute.html">ehrapy.preprocessing.simple_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.knn_impute.html">ehrapy.preprocessing.knn_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.miss_forest_impute.html">ehrapy.preprocessing.miss_forest_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.soft_impute.html">ehrapy.preprocessing.soft_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.iterative_svd_impute.html">ehrapy.preprocessing.iterative_svd_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.matrix_factorization_impute.html">ehrapy.preprocessing.matrix_factorization_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.nuclear_norm_minimization_impute.html">ehrapy.preprocessing.nuclear_norm_minimization_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/imputation/ehrapy.preprocessing.mice_forest_impute.html">ehrapy.preprocessing.mice_forest_impute</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.encode.html">ehrapy.preprocessing.encode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.undo_encoding.html">ehrapy.preprocessing.undo_encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.log_norm.html">ehrapy.preprocessing.log_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.maxabs_norm.html">ehrapy.preprocessing.maxabs_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.minmax_norm.html">ehrapy.preprocessing.minmax_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.power_norm.html">ehrapy.preprocessing.power_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.quantile_norm.html">ehrapy.preprocessing.quantile_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.robust_scale_norm.html">ehrapy.preprocessing.robust_scale_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.scale_norm.html">ehrapy.preprocessing.scale_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.sqrt_norm.html">ehrapy.preprocessing.sqrt_norm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.combat.html">ehrapy.preprocessing.combat</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/preprocessing/ehrapy.preprocessing.neighbors.html">ehrapy.preprocessing.neighbors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.pca.html">ehrapy.tools.pca</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.tsne.html">ehrapy.tools.tsne</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.umap.html">ehrapy.tools.umap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.draw_graph.html">ehrapy.tools.draw_graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.diffmap.html">ehrapy.tools.diffmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.embedding_density.html">ehrapy.tools.embedding_density</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.leiden.html">ehrapy.tools.leiden</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.louvain.html">ehrapy.tools.louvain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.dendrogram.html">ehrapy.tools.dendrogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.dpt.html">ehrapy.tools.dpt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.paga.html">ehrapy.tools.paga</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.rank_features_groups.html">ehrapy.tools.rank_features_groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.filter_rank_features_groups.html">ehrapy.tools.filter_rank_features_groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.marker_feature_overlap.html">ehrapy.tools.marker_feature_overlap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.ingest.html">ehrapy.tools.ingest</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.Translator.html">ehrapy.tools.Translator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.HPOMapper.html">ehrapy.tools.HPOMapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.MedCAT.html">ehrapy.tools.MedCAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.mc.run_unsupervised_training.html">ehrapy.tools.mc.run_unsupervised_training</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.mc.annotate_text.html">ehrapy.tools.mc.annotate_text</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.mc.get_annotation_overview.html">ehrapy.tools.mc.get_annotation_overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.ols.html">ehrapy.tools.ols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.glm.html">ehrapy.tools.glm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.tools.kmf.html">ehrapy.tools.kmf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.scatter.html">ehrapy.plot.scatter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.heatmap.html">ehrapy.plot.heatmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.dotplot.html">ehrapy.plot.dotplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.tracksplot.html">ehrapy.plot.tracksplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.violin.html">ehrapy.plot.violin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.stacked_violin.html">ehrapy.plot.stacked_violin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.matrixplot.html">ehrapy.plot.matrixplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.clustermap.html">ehrapy.plot.clustermap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.ranking.html">ehrapy.plot.ranking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.dendrogram.html">ehrapy.plot.dendrogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.qc_metrics.html">ehrapy.plot.qc_metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.pca.html">ehrapy.plot.pca</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.pca_loadings.html">ehrapy.plot.pca_loadings</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.pca_variance_ratio.html">ehrapy.plot.pca_variance_ratio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.pca_overview.html">ehrapy.plot.pca_overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.tsne.html">ehrapy.plot.tsne</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.umap.html">ehrapy.plot.umap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.diffmap.html">ehrapy.plot.diffmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.draw_graph.html">ehrapy.plot.draw_graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.spatial.html">ehrapy.plot.spatial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.embedding.html">ehrapy.plot.embedding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.embedding_density.html">ehrapy.plot.embedding_density</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.dpt_groups_pseudotime.html">ehrapy.plot.dpt_groups_pseudotime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.dpt_timeseries.html">ehrapy.plot.dpt_timeseries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.paga.html">ehrapy.plot.paga</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.paga_path.html">ehrapy.plot.paga_path</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.paga_compare.html">ehrapy.plot.paga_compare</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups.html">ehrapy.plot.rank_features_groups</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_violin.html">ehrapy.plot.rank_features_groups_violin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_stacked_violin.html">ehrapy.plot.rank_features_groups_stacked_violin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_heatmap.html">ehrapy.plot.rank_features_groups_heatmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_dotplot.html">ehrapy.plot.rank_features_groups_dotplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_matrixplot.html">ehrapy.plot.rank_features_groups_matrixplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/plot/ehrapy.plot.rank_features_groups_tracksplot.html">ehrapy.plot.rank_features_groups_tracksplot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.plot.ols.html">ehrapy.plot.ols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/tools/ehrapy.plot.kmf.html">ehrapy.plot.kmf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/anndata/ehrapy.anndata.df_to_anndata.html">ehrapy.anndata.df_to_anndata</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/anndata/ehrapy.anndata.anndata_to_df.html">ehrapy.anndata.anndata_to_df</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/anndata/ehrapy.anndata.move_to_obs.html">ehrapy.anndata.move_to_obs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/anndata/ehrapy.anndata.move_to_x.html">ehrapy.anndata.move_to_x</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/anndata/ehrapy.anndata.type_overview.html">ehrapy.anndata.type_overview</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/ehrapy_introduction.html">Introduction to ehrapy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/mimic_2_introduction.html">MIMIC-II IAC Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/mimic_2_fate.html">MIMIC-II Patient Fate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/mimic_2_survival_analysis.html">MIMIC-II Survival Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/diabetes_130.html">Diabetes 130 Vignette</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/notebooks/medcat.html">Extracting from free text with MedCAT</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributor Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../code_of_conduct.html">Code of Conduct</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/theislab/ehrapy/discussions">Discussions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for ehrapy.tools._scanpy_tl_api</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MappingProxyType</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">from</span> <span class="nn">anndata</span> <span class="kn">import</span> <span class="n">AnnData</span>
<span class="kn">from</span> <span class="nn">leidenalg.VertexPartition</span> <span class="kn">import</span> <span class="n">MutableVertexPartition</span>
<span class="kn">from</span> <span class="nn">scanpy._utils</span> <span class="kn">import</span> <span class="n">AnyRandom</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">spmatrix</span>

<span class="kn">from</span> <span class="nn">ehrapy.preprocessing._scanpy_pp_api</span> <span class="kn">import</span> <span class="n">pca</span>  <span class="c1"># noqa: E402,F403,F401</span>


<div class="viewcode-block" id="tsne"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.tsne.html#ehrapy.tools.tsne">[docs]</a><span class="k">def</span> <span class="nf">tsne</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">n_pcs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_rep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">perplexity</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">early_exaggeration</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">learning_rate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">:</span> <span class="n">AnyRandom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AnnData</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Calculates t-SNE [Maaten08]_ [Amir13]_ [Pedregosa11]_.</span>

<span class="sd">    t-distributed stochastic neighborhood embedding (tSNE) [Maaten08]_ has been</span>
<span class="sd">    proposed for visualizing complex by [Amir13]_. Here, by default, we use the implementation of *scikit-learn* [Pedregosa11]_.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        n_pcs: Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.</span>
<span class="sd">        use_rep: Use the indicated representation. `&#39;X&#39;` or any key for `.obsm` is valid.</span>
<span class="sd">                 If `None`, the representation is chosen automatically:</span>
<span class="sd">                 For `.n_vars` &lt; 50, `.X` is used, otherwise &#39;X_pca&#39; is used.</span>
<span class="sd">                 If &#39;X_pca&#39; is not present, it’s computed with default parameters.</span>
<span class="sd">        perplexity: The perplexity is related to the number of nearest neighbors that</span>
<span class="sd">                    is used in other manifold learning algorithms. Larger datasets usually require a larger perplexity.</span>
<span class="sd">                    Consider selecting a value between 5 and 50. The choice is not extremely critical since t-SNE</span>
<span class="sd">                    is quite insensitive to this parameter.</span>
<span class="sd">        early_exaggeration: Controls how tight natural clusters in the original space are in the</span>
<span class="sd">                            embedded space and how much space will be between them. For larger</span>
<span class="sd">                            values, the space between natural clusters will be larger in the</span>
<span class="sd">                            embedded space. Again, the choice of this parameter is not very</span>
<span class="sd">                            critical. If the cost function increases during initial optimization,</span>
<span class="sd">                            the early exaggeration factor or the learning rate might be too high.</span>
<span class="sd">        learning_rate: Note that the R-package &quot;Rtsne&quot; uses a default of 200.</span>
<span class="sd">                       The learning rate can be a critical parameter. It should be</span>
<span class="sd">                       between 100 and 1000. If the cost function increases during initial</span>
<span class="sd">                       optimization, the early exaggeration factor or the learning rate</span>
<span class="sd">                       might be too high. If the cost function gets stuck in a bad local</span>
<span class="sd">                       minimum increasing the learning rate helps sometimes.</span>
<span class="sd">        random_state: Change this to use different intial states for the optimization.</span>
<span class="sd">                      If `None`, the initial state is not reproducible.</span>
<span class="sd">        n_jobs: Number of jobs for parallel computation.</span>
<span class="sd">                `None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.</span>
<span class="sd">        copy: Return a copy instead of writing to `adata`.</span>
<span class="sd">        metric: Distance metric calculate neighbors on.</span>

<span class="sd">    Returns:</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">tsne</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">n_pcs</span><span class="o">=</span><span class="n">n_pcs</span><span class="p">,</span>
        <span class="n">use_rep</span><span class="o">=</span><span class="n">use_rep</span><span class="p">,</span>
        <span class="n">perplexity</span><span class="o">=</span><span class="n">perplexity</span><span class="p">,</span>
        <span class="n">early_exaggeration</span><span class="o">=</span><span class="n">early_exaggeration</span><span class="p">,</span>
        <span class="n">learning_rate</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="n">_InitPos</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;paga&quot;</span><span class="p">,</span> <span class="s2">&quot;spectral&quot;</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="umap"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.umap.html#ehrapy.tools.umap">[docs]</a><span class="k">def</span> <span class="nf">umap</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">min_dist</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">spread</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">maxiter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">negative_sample_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">init_pos</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">_InitPos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;spectral&quot;</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">:</span> <span class="n">AnyRandom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;umap&quot;</span><span class="p">,</span> <span class="s2">&quot;rapids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;umap&quot;</span><span class="p">,</span>
    <span class="n">neighbors_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AnnData</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Embed the neighborhood graph using UMAP [McInnes18]_.</span>

<span class="sd">    UMAP (Uniform Manifold Approximation and Projection) is a manifold learning</span>
<span class="sd">    technique suitable for visualizing high-dimensional data. Besides tending to</span>
<span class="sd">    be faster than tSNE, it optimizes the embedding such that it best reflects</span>
<span class="sd">    the topology of the data, which we represent throughout ehrapy using a</span>
<span class="sd">    neighborhood graph. tSNE, by contrast, optimizes the distribution of</span>
<span class="sd">    nearest-neighbor distances in the embedding such that these best match the</span>
<span class="sd">    distribution of distances in the high-dimensional space. We use the</span>
<span class="sd">    implementation of `umap-learn &lt;https://github.com/lmcinnes/umap&gt;`__</span>
<span class="sd">    [McInnes18]_. For a few comparisons of UMAP with tSNE, see this `preprint</span>
<span class="sd">    &lt;https://doi.org/10.1101/298430&gt;`__.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        min_dist: The effective minimum distance between embedded points. Smaller values</span>
<span class="sd">                  will result in a more clustered/clumped embedding where nearby points on</span>
<span class="sd">                  the manifold are drawn closer together, while larger values will result</span>
<span class="sd">                  on a more even dispersal of points. The value should be set relative to</span>
<span class="sd">                  the ``spread`` value, which determines the scale at which embedded</span>
<span class="sd">                  points will be spread out. The default of in the `umap-learn` package is 0.1.</span>
<span class="sd">        spread: The effective scale of embedded points.</span>
<span class="sd">                In combination with `min_dist` this determines how clustered/clumped the embedded points are.</span>
<span class="sd">        n_components: The number of dimensions of the embedding.</span>
<span class="sd">        maxiter: The number of iterations (epochs) of the optimization. Called `n_epochs` in the original UMAP.</span>
<span class="sd">        alpha: The initial learning rate for the embedding optimization.</span>
<span class="sd">        gamma: Weighting applied to negative samples in low dimensional embedding optimization.</span>
<span class="sd">               Values higher than one will result in greater weight being given to negative samples.</span>
<span class="sd">        negative_sample_rate: The number of negative edge/1-simplex samples to use per positive</span>
<span class="sd">                              edge/1-simplex sample in optimizing the low dimensional embedding.</span>
<span class="sd">        init_pos: How to initialize the low dimensional embedding. Called `init` in the original UMAP. Options are:</span>

<span class="sd">                  * Any key for `adata.obsm`.</span>

<span class="sd">                  * &#39;paga&#39;: positions from :func:`~scanpy.pl.paga`.</span>

<span class="sd">                  * &#39;spectral&#39;: use a spectral embedding of the graph.</span>

<span class="sd">                  * &#39;random&#39;: assign initial embedding positions at random.</span>

<span class="sd">                  * A numpy array of initial embedding positions.</span>
<span class="sd">        random_state: Random state for the initialization.</span>

<span class="sd">                      * If `int`, `random_state` is the seed used by the random number generator;</span>

<span class="sd">                      * If `RandomState` or `Generator`, `random_state` is the random number generator;</span>

<span class="sd">                      * If `None`, the random number generator is the `RandomState` instance used by `np.random`.</span>
<span class="sd">        a: More specific parameters controlling the embedding.</span>
<span class="sd">           If `None` these values are set automatically as determined by `min_dist` and `spread`.</span>
<span class="sd">        b: More specific parameters controlling the embedding.</span>
<span class="sd">           If `None` these values are set automatically as determined by `min_dist` and `spread`.</span>
<span class="sd">        copy: Return a copy instead of writing to adata.</span>
<span class="sd">        method: Use the original &#39;umap&#39; implementation, or &#39;rapids&#39; (experimental, GPU only)</span>
<span class="sd">        neighbors_key: If not specified, umap looks .uns[&#39;neighbors&#39;] for neighbors settings</span>
<span class="sd">                       and .obsp[&#39;connectivities&#39;] for connectivities (default storage places for pp.neighbors).</span>
<span class="sd">                       If specified, umap looks .uns[neighbors_key] for neighbors settings and</span>
<span class="sd">                       .obsp[.uns[neighbors_key][&#39;connectivities_key&#39;]] for connectivities.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Depending on `copy`, returns or updates `adata` with the following fields.</span>

<span class="sd">        **X_umap** : `adata.obsm` field UMAP coordinates of data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">umap</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span><span class="p">,</span>
        <span class="n">spread</span><span class="o">=</span><span class="n">spread</span><span class="p">,</span>
        <span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
        <span class="n">maxiter</span><span class="o">=</span><span class="n">maxiter</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">,</span>
        <span class="n">negative_sample_rate</span><span class="o">=</span><span class="n">negative_sample_rate</span><span class="p">,</span>
        <span class="n">init_pos</span><span class="o">=</span><span class="n">init_pos</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
        <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="n">neighbors_key</span><span class="o">=</span><span class="n">neighbors_key</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="n">_LAYOUTS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;fr&quot;</span><span class="p">,</span> <span class="s2">&quot;drl&quot;</span><span class="p">,</span> <span class="s2">&quot;kk&quot;</span><span class="p">,</span> <span class="s2">&quot;grid_fr&quot;</span><span class="p">,</span> <span class="s2">&quot;lgl&quot;</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="s2">&quot;rt_circular&quot;</span><span class="p">,</span> <span class="s2">&quot;fa&quot;</span><span class="p">)</span>
<span class="n">_Layout</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="n">_LAYOUTS</span><span class="p">]</span>  <span class="c1"># type: ignore</span>


<div class="viewcode-block" id="draw_graph"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.draw_graph.html#ehrapy.tools.draw_graph">[docs]</a><span class="k">def</span> <span class="nf">draw_graph</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">layout</span><span class="p">:</span> <span class="n">_Layout</span> <span class="o">=</span> <span class="s2">&quot;fa&quot;</span><span class="p">,</span>
    <span class="n">init_pos</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">:</span> <span class="n">AnyRandom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">n_jobs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">adjacency</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">spmatrix</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_added_ext</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">neighbors_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obsp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AnnData</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Force-directed graph drawing [Islam11]_ [Jacomy14]_ [Chippada18]_.</span>

<span class="sd">    .. _fa2: https://github.com/bhargavchippada/forceatlas2</span>
<span class="sd">    .. _Force-directed graph drawing: https://en.wikipedia.org/wiki/Force-directed_graph_drawing</span>
<span class="sd">    .. _fruchterman-reingold: http://igraph.org/python/doc/igraph.Graph-class.html#layout_fruchterman_reingold</span>

<span class="sd">    An alternative to tSNE that often preserves the topology of the data</span>
<span class="sd">    better. This requires to run :func:`~ehrapy.pp.neighbors`, first.</span>
<span class="sd">    The default layout (&#39;fa&#39;, `ForceAtlas2`) [Jacomy14]_ uses the package `fa2`_</span>
<span class="sd">    [Chippada18]_, which can be installed via `pip install fa2`.</span>
<span class="sd">    `Force-directed graph drawing`_ describes a class of long-established</span>
<span class="sd">    algorithms for visualizing graphs.</span>
<span class="sd">    It has been suggested for visualizing single-cell data by [Islam11]_.</span>
<span class="sd">    Many other layouts as implemented in igraph [Csardi06]_ are available.</span>
<span class="sd">    Similar approaches have been used by [Zunder15]_ or [Weinreb17]_.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        layout: &#39;fa&#39; (`ForceAtlas2`) or any valid `igraph layout</span>
<span class="sd">                &lt;http://igraph.org/c/doc/igraph-Layout.html&gt;`__. Of particular interest</span>
<span class="sd">                are &#39;fr&#39; (Fruchterman Reingold), &#39;grid_fr&#39; (Grid Fruchterman Reingold,</span>
<span class="sd">                faster than &#39;fr&#39;), &#39;kk&#39; (Kamadi Kawai&#39;, slower than &#39;fr&#39;), &#39;lgl&#39; (Large</span>
<span class="sd">                Graph, very fast), &#39;drl&#39; (Distributed Recursive Layout, pretty fast) and</span>
<span class="sd">                &#39;rt&#39; (Reingold Tilford tree layout).</span>
<span class="sd">        init_pos: `&#39;paga&#39;`/`True`, `None`/`False`, or any valid 2d-`.obsm` key.</span>
<span class="sd">                  Use precomputed coordinates for initialization.</span>
<span class="sd">                  If `False`/`None` (the default), initialize randomly.</span>
<span class="sd">        root: Root for tree layouts.</span>
<span class="sd">        random_state: For layouts with random initialization like &#39;fr&#39;, change this to use</span>
<span class="sd">                      different intial states for the optimization. If `None`, no seed is set.</span>
<span class="sd">        n_jobs: Number of jobs for parallel computation.</span>
<span class="sd">                `None` means using :attr:`scanpy._settings.ScanpyConfig.n_jobs`.</span>
<span class="sd">        adjacency: Sparse adjacency matrix of the graph, defaults to neighbors connectivities.</span>
<span class="sd">        key_added_ext: By default, append `layout`.</span>
<span class="sd">        neighbors_key: If not specified, draw_graph looks .obsp[&#39;connectivities&#39;] for connectivities</span>
<span class="sd">                       (default storage place for pp.neighbors).</span>
<span class="sd">                       If specified, draw_graph looks .obsp[.uns[neighbors_key][&#39;connectivities_key&#39;]] for connectivities.</span>
<span class="sd">        obsp:  Use .obsp[obsp] as adjacency. You can&#39;t specify both `obsp` and `neighbors_key` at the same time.</span>
<span class="sd">        copy: Whether to return a copy instead of writing to adata.</span>
<span class="sd">        **kwds: Parameters of chosen igraph layout. See e.g. `fruchterman-reingold`_</span>
<span class="sd">                [Fruchterman91]_. One of the most important ones is `maxiter`.</span>

<span class="sd">    Returns:</span>
<span class="sd">          Depending on `copy`, returns or updates `adata` with the following field.</span>

<span class="sd">          **X_draw_graph_layout** : `adata.obsm`</span>
<span class="sd">          Coordinates of graph layout. E.g. for layout=&#39;fa&#39; (the default), the field is called &#39;X_draw_graph_fa&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">draw_graph</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span>
        <span class="n">init_pos</span><span class="o">=</span><span class="n">init_pos</span><span class="p">,</span>
        <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
        <span class="n">adjacency</span><span class="o">=</span><span class="n">adjacency</span><span class="p">,</span>
        <span class="n">key_added_ext</span><span class="o">=</span><span class="n">key_added_ext</span><span class="p">,</span>
        <span class="n">neighbors_key</span><span class="o">=</span><span class="n">neighbors_key</span><span class="p">,</span>
        <span class="n">obsp</span><span class="o">=</span><span class="n">obsp</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="diffmap"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.diffmap.html#ehrapy.tools.diffmap">[docs]</a><span class="k">def</span> <span class="nf">diffmap</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">n_comps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>
    <span class="n">neighbors_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">:</span> <span class="n">AnyRandom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AnnData</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Diffusion Maps [Coifman05]_ [Haghverdi15]_ [Wolf18]_.</span>

<span class="sd">    Diffusion maps [Coifman05]_ has been proposed for visualizing single-cell</span>
<span class="sd">    data by [Haghverdi15]_. The tool uses the adapted Gaussian kernel suggested</span>
<span class="sd">    by [Haghverdi16]_ in the implementation of [Wolf18]_.</span>
<span class="sd">    The width (&quot;sigma&quot;) of the connectivity kernel is implicitly determined by</span>
<span class="sd">    the number of neighbors used to compute the single-cell graph in</span>
<span class="sd">    :func:`~ehrapy.pp.neighbors`. To reproduce the original implementation</span>
<span class="sd">    using a Gaussian kernel, use `method==&#39;gauss&#39;` in</span>
<span class="sd">    :func:`~ehrapy.pp.neighbors`. To use an exponential kernel, use the default</span>
<span class="sd">    `method==&#39;umap&#39;`. Differences between these options shouldn&#39;t usually be dramatic.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        n_comps: The number of dimensions of the representation.</span>
<span class="sd">                 neighbors_key: If not specified, diffmap looks .uns[&#39;neighbors&#39;] for neighbors settings</span>
<span class="sd">                 and .obsp[&#39;connectivities&#39;], .obsp[&#39;distances&#39;] for connectivities and</span>
<span class="sd">                 distances respectively (default storage places for pp.neighbors).</span>
<span class="sd">                 If specified, diffmap looks .uns[neighbors_key] for neighbors settings and</span>
<span class="sd">                 .obsp[.uns[neighbors_key][&#39;connectivities_key&#39;]],</span>
<span class="sd">                 .obsp[.uns[neighbors_key][&#39;distances_key&#39;]] for connectivities and distances respectively.</span>
<span class="sd">        random_state: Random seed for the initialization.</span>
<span class="sd">        copy: Whether to return a copy of the :class:`~anndata.AnnData` object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Depending on `copy`, returns or updates `adata` with the following fields.</span>

<span class="sd">        `X_diffmap` : :class:`numpy.ndarray` (`adata.obsm`)</span>
<span class="sd">        Diffusion map representation of data, which is the right eigen basis of the transition matrix with eigenvectors as columns.</span>

<span class="sd">        `diffmap_evals` : :class:`numpy.ndarray` (`adata.uns`)</span>
<span class="sd">        Array of size (number of eigen vectors). Eigenvalues of transition matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">diffmap</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="n">n_comps</span><span class="p">,</span> <span class="n">neighbors_key</span><span class="o">=</span><span class="n">neighbors_key</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="embedding_density"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.embedding_density.html#ehrapy.tools.embedding_density">[docs]</a><span class="k">def</span> <span class="nf">embedding_density</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">basis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;umap&quot;</span><span class="p">,</span>  <span class="c1"># was positional before 1.4.5</span>
    <span class="n">groupby</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_added</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">components</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Calculate the density of observation in an embedding (per condition).</span>
<span class="sd">    Gaussian kernel density estimation is used to calculate the density of</span>
<span class="sd">    observations in an embedded space. This can be performed per category over a</span>
<span class="sd">    categorical observation annotation. The cell density can be plotted using the</span>
<span class="sd">    `sc.pl.embedding_density()` function.</span>
<span class="sd">    Note that density values are scaled to be between 0 and 1. Thus, the</span>
<span class="sd">    density value at each cell is only comparable to other densities in</span>
<span class="sd">    the same condition category.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        basis: The embedding over which the density will be calculated. This embedded</span>
<span class="sd">               representation should be found in `adata.obsm[&#39;X_[basis]&#39;]``.</span>
<span class="sd">        groupby: Keys for categorical observation/cell annotation for which densities</span>
<span class="sd">                 are calculated per category. Columns with up to ten categories are accepted.</span>
<span class="sd">        key_added: Name of the `.obs` covariate that will be added with the density estimates.</span>
<span class="sd">        components: The embedding dimensions over which the density should be calculated.</span>
<span class="sd">                    This is limited to two components.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Updates `adata.obs` with an additional field specified by the `key_added`</span>
<span class="sd">        parameter. This parameter defaults to `[basis]_density_[groupby]`, where</span>
<span class="sd">        where `[basis]` is one of `umap`, `diffmap`, `pca`, `tsne`, or `draw_graph_fa`</span>
<span class="sd">        and `[groupby]` denotes the parameter input.</span>
<span class="sd">        Updates `adata.uns` with an additional field `[key_added]_params`.</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            adata = ep.data.mimic_2(encode=True)</span>
<span class="sd">            ep.tl.umap(adata)</span>
<span class="sd">            ep.tl.embedding_density(adata, basis=&#39;umap&#39;, groupby=&#39;phase&#39;)</span>
<span class="sd">            ep.pl.embedding_density(adata, basis=&#39;umap&#39;, key=&#39;umap_density_phase&#39;, group=&#39;G1&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">embedding_density</span><span class="p">(</span><span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span> <span class="n">key_added</span><span class="o">=</span><span class="n">key_added</span><span class="p">,</span> <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">)</span></div>


<div class="viewcode-block" id="leiden"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.leiden.html#ehrapy.tools.leiden">[docs]</a><span class="k">def</span> <span class="nf">leiden</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">resolution</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">restrict_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">:</span> <span class="n">AnyRandom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">key_added</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;leiden&quot;</span><span class="p">,</span>
    <span class="n">adjacency</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">spmatrix</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">use_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">n_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">partition_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">MutableVertexPartition</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">neighbors_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obsp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">partition_kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AnnData</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Cluster observations into subgroups [Traag18]_.</span>

<span class="sd">    Cluster observations using the Leiden algorithm [Traag18]_,</span>
<span class="sd">    an improved version of the Louvain algorithm [Blondel08]_.</span>
<span class="sd">    It has been proposed for single-cell analysis by [Levine15]_.</span>
<span class="sd">    This requires having ran :func:`~ehrapy.pp.neighbors` or :func:`~ehrapy.pp.bbknn` first.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        resolution: A parameter value controlling the coarseness of the clustering. Higher values lead to more clusters.</span>
<span class="sd">                    Set to `None` if overriding `partition_type` to one that doesn’t accept a `resolution_parameter`.</span>
<span class="sd">        restrict_to: Restrict the clustering to the categories within the key for sample</span>
<span class="sd">                     annotation, tuple needs to contain `(obs_key, list_of_categories)`.</span>
<span class="sd">        random_state: Random seed of the initialization of the optimization.</span>
<span class="sd">        key_added: `adata.obs` key under which to add the cluster labels.</span>
<span class="sd">        adjacency: Sparse adjacency matrix of the graph, defaults to neighbors connectivities.</span>
<span class="sd">        directed: Whether to treat the graph as directed or undirected.</span>
<span class="sd">        use_weights: If `True`, edge weights from the graph are used in the computation</span>
<span class="sd">                     (placing more emphasis on stronger edges).</span>
<span class="sd">        n_iterations: How many iterations of the Leiden clustering algorithm to perform.</span>
<span class="sd">                      Positive values above 2 define the total number of iterations to perform,</span>
<span class="sd">                      -1 has the algorithm run until it reaches its optimal clustering.</span>
<span class="sd">        partition_type: Type of partition to use.</span>
<span class="sd">                        Defaults to :class:`~leidenalg.RBConfigurationVertexPartition`.</span>
<span class="sd">                        For the available options, consult the documentation for</span>
<span class="sd">                        :func:`~leidenalg.find_partition`.</span>
<span class="sd">        neighbors_key: Use neighbors connectivities as adjacency.</span>
<span class="sd">                       If not specified, leiden looks .obsp[&#39;connectivities&#39;] for connectivities</span>
<span class="sd">                       (default storage place for pp.neighbors).</span>
<span class="sd">                       If specified, leiden looks .obsp[.uns[neighbors_key][&#39;connectivities_key&#39;]] for connectivities.</span>
<span class="sd">        obsp: Use .obsp[obsp] as adjacency. You can&#39;t specify both `obsp` and `neighbors_key` at the same time.</span>
<span class="sd">        copy: Whether to copy `adata` or modify it inplace.</span>
<span class="sd">        **partition_kwargs: Any further arguments to pass to `~leidenalg.find_partition`</span>
<span class="sd">                            (which in turn passes arguments to the `partition_type`).</span>

<span class="sd">    Returns:</span>
<span class="sd">        `adata.obs[key_added]`</span>
<span class="sd">        Array of dim (number of samples) that stores the subgroup id (`&#39;0&#39;`, `&#39;1&#39;`, ...) for each cell.</span>

<span class="sd">        `adata.uns[&#39;leiden&#39;][&#39;params&#39;]`</span>
<span class="sd">        A dict with the values for the parameters `resolution`, `random_state`, and `n_iterations`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">leiden</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span>
        <span class="n">restrict_to</span><span class="o">=</span><span class="n">restrict_to</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="n">key_added</span><span class="o">=</span><span class="n">key_added</span><span class="p">,</span>
        <span class="n">adjacency</span><span class="o">=</span><span class="n">adjacency</span><span class="p">,</span>
        <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span>
        <span class="n">use_weights</span><span class="o">=</span><span class="n">use_weights</span><span class="p">,</span>
        <span class="n">n_iterations</span><span class="o">=</span><span class="n">n_iterations</span><span class="p">,</span>
        <span class="n">partition_type</span><span class="o">=</span><span class="n">partition_type</span><span class="p">,</span>
        <span class="n">neighbors_key</span><span class="o">=</span><span class="n">neighbors_key</span><span class="p">,</span>
        <span class="n">obsp</span><span class="o">=</span><span class="n">obsp</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="o">**</span><span class="n">partition_kwargs</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="louvain"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.louvain.html#ehrapy.tools.louvain">[docs]</a><span class="k">def</span> <span class="nf">louvain</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">resolution</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">:</span> <span class="n">AnyRandom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">restrict_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_added</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;louvain&quot;</span><span class="p">,</span>
    <span class="n">adjacency</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">spmatrix</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">flavor</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;vtraag&quot;</span><span class="p">,</span> <span class="s2">&quot;igraph&quot;</span><span class="p">,</span> <span class="s2">&quot;rapids&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;vtraag&quot;</span><span class="p">,</span>
    <span class="n">directed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">use_weights</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">partition_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">MutableVertexPartition</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">partition_kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">MappingProxyType</span><span class="p">({}),</span>
    <span class="n">neighbors_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obsp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AnnData</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Cluster observations into subgroups [Blondel08]_ [Levine15]_ [Traag17]_.</span>

<span class="sd">    Cluster observations using the Louvain algorithm [Blondel08]_ in the implementation of [Traag17]_.</span>
<span class="sd">    The Louvain algorithm has been proposed for single-cell analysis by [Levine15]_.</span>
<span class="sd">    This requires having ran :func:`~ehrapy.pp.neighbors` or</span>
<span class="sd">    :func:`~ehrapy.pp.bbknn` first, or explicitly passing a ``adjacency`` matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        resolution: For the default flavor (``&#39;vtraag&#39;``), you can provide a resolution</span>
<span class="sd">                    (higher resolution means finding more and smaller clusters),</span>
<span class="sd">                    which defaults to 1.0. See “Time as a resolution parameter” in [Lambiotte09]_.</span>
<span class="sd">        random_state: Random seed of the initialization of the optimization.</span>
<span class="sd">        restrict_to: Restrict the clustering to the categories within the key for sample</span>
<span class="sd">                     annotation, tuple needs to contain ``(obs_key, list_of_categories)``.</span>
<span class="sd">        key_added: Key under which to add the cluster labels. (default: ``&#39;louvain&#39;``)</span>
<span class="sd">        adjacency: Sparse adjacency matrix of the graph, defaults to neighbors connectivities.</span>
<span class="sd">        flavor: Choose between to packages for computing the clustering.</span>
<span class="sd">                ``&#39;vtraag&#39;`` is much more powerful, and the default.</span>
<span class="sd">        directed: Interpret the ``adjacency`` matrix as directed graph?</span>
<span class="sd">        use_weights: Use weights from knn graph.</span>
<span class="sd">        partition_type: Type of partition to use. Only a valid argument if ``flavor`` is ``&#39;vtraag&#39;``.</span>
<span class="sd">        partition_kwargs: Key word arguments to pass to partitioning, if ``vtraag`` method is being used.</span>
<span class="sd">        neighbors_key: Use neighbors connectivities as adjacency.</span>
<span class="sd">                       If not specified, louvain looks .obsp[&#39;connectivities&#39;] for connectivities</span>
<span class="sd">                       (default storage place for pp.neighbors).</span>
<span class="sd">                       If specified, louvain looks .obsp[.uns[neighbors_key][&#39;connectivities_key&#39;]] for connectivities.</span>
<span class="sd">        obsp: Use .obsp[obsp] as adjacency. You can&#39;t specify both `obsp` and `neighbors_key` at the same time.</span>
<span class="sd">        copy: Whether to copy `adata` or modify it inplace.</span>

<span class="sd">    Returns:</span>
<span class="sd">        By default (``copy=False``), updates ``adata`` with the following fields:</span>
<span class="sd">        ``adata.obs[&#39;louvain&#39;]`` (:class:`pandas.Series`, dtype ``category``)</span>
<span class="sd">        Array of dim (number of samples) that stores the subgroup id (``&#39;0&#39;``, ``&#39;1&#39;``, ...) for each observation.</span>

<span class="sd">        :class:`~anndata.AnnData`</span>
<span class="sd">        When ``copy=True`` is set, a copy of ``adata`` with those fields is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">louvain</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="n">restrict_to</span><span class="o">=</span><span class="n">restrict_to</span><span class="p">,</span>
        <span class="n">key_added</span><span class="o">=</span><span class="n">key_added</span><span class="p">,</span>
        <span class="n">adjacency</span><span class="o">=</span><span class="n">adjacency</span><span class="p">,</span>
        <span class="n">flavor</span><span class="o">=</span><span class="n">flavor</span><span class="p">,</span>
        <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span>
        <span class="n">use_weights</span><span class="o">=</span><span class="n">use_weights</span><span class="p">,</span>
        <span class="n">partition_type</span><span class="o">=</span><span class="n">partition_type</span><span class="p">,</span>
        <span class="n">partition_kwargs</span><span class="o">=</span><span class="n">partition_kwargs</span><span class="p">,</span>
        <span class="n">neighbors_key</span><span class="o">=</span><span class="n">neighbors_key</span><span class="p">,</span>
        <span class="n">obsp</span><span class="o">=</span><span class="n">obsp</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dendrogram"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.dendrogram.html#ehrapy.tools.dendrogram">[docs]</a><span class="k">def</span> <span class="nf">dendrogram</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">groupby</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">n_pcs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_rep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cor_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pearson&quot;</span><span class="p">,</span>
    <span class="n">linkage_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;complete&quot;</span><span class="p">,</span>
    <span class="n">optimal_ordering</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_added</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Computes a hierarchical clustering for the given `groupby` categories.</span>

<span class="sd">    By default, the PCA representation is used unless `.X` has less than 50 variables.</span>
<span class="sd">    Alternatively, a list of `var_names` (e.g. genes) can be given.</span>
<span class="sd">    Average values of either `var_names` or components are used to compute a correlation matrix.</span>

<span class="sd">    The hierarchical clustering can be visualized using</span>
<span class="sd">    :func:`ehrapy.pl.dendrogram` or multiple other visualizations that can</span>
<span class="sd">    include a dendrogram: :func:`~ehrapy.pl.matrixplot`,</span>
<span class="sd">    :func:`~ehrapy.pl.heatmap`, :func:`~ehrapy.pl.dotplot`,</span>
<span class="sd">    and :func:`~ehrapy.pl.stacked_violin`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The computation of the hierarchical clustering is based on predefined</span>
<span class="sd">        groups and not per observation. The correlation matrix is computed using by</span>
<span class="sd">        default pearson but other methods are available.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        groupby: Key to group by</span>
<span class="sd">        n_pcs: Use this many PCs. If `n_pcs==0` use `.X` if `use_rep is None`.</span>
<span class="sd">        use_rep: Use the indicated representation. `&#39;X&#39;` or any key for `.obsm` is valid.</span>
<span class="sd">                 If `None`, the representation is chosen automatically:</span>
<span class="sd">                 For `.n_vars` &lt; 50, `.X` is used, otherwise &#39;X_pca&#39; is used.</span>
<span class="sd">                 If &#39;X_pca&#39; is not present, it’s computed with default parameters.</span>
<span class="sd">        var_names: List of var_names to use for computing the hierarchical clustering.</span>
<span class="sd">                   If `var_names` is given, then `use_rep` and `n_pcs` is ignored.</span>
<span class="sd">        cor_method: correlation method to use.</span>
<span class="sd">                    Options are &#39;pearson&#39;, &#39;kendall&#39;, and &#39;spearman&#39;</span>
<span class="sd">        linkage_method: linkage method to use. See :func:`scipy.cluster.hierarchy.linkage` for more information.</span>
<span class="sd">        optimal_ordering: Same as the optimal_ordering argument of :func:`scipy.cluster.hierarchy.linkage`</span>
<span class="sd">                          which reorders the linkage matrix so that the distance between successive leaves is minimal.</span>
<span class="sd">        key_added: By default, the dendrogram information is added to</span>
<span class="sd">                   `.uns[f&#39;dendrogram_{{groupby}}&#39;]`.</span>
<span class="sd">                   Notice that the `groupby` information is added to the dendrogram.</span>
<span class="sd">        inplace: If `True`, adds dendrogram information to `adata.uns[key_added]`,</span>
<span class="sd">                 else this function returns the information.</span>
<span class="sd">    Returns:</span>
<span class="sd">        If `inplace=False`, returns dendrogram information, else `adata.uns[key_added]` is updated with it.</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>
<span class="sd">            adata = ep.data.mimic_2(encode=True)</span>
<span class="sd">            ep.tl.dendrogram(adata, groupby=&#39;service_unit&#39;)</span>
<span class="sd">            ep.pl.dendrogram(adata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">dendrogram</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span>
        <span class="n">n_pcs</span><span class="o">=</span><span class="n">n_pcs</span><span class="p">,</span>
        <span class="n">use_rep</span><span class="o">=</span><span class="n">use_rep</span><span class="p">,</span>
        <span class="n">var_names</span><span class="o">=</span><span class="n">var_names</span><span class="p">,</span>
        <span class="n">use_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cor_method</span><span class="o">=</span><span class="n">cor_method</span><span class="p">,</span>
        <span class="n">linkage_method</span><span class="o">=</span><span class="n">linkage_method</span><span class="p">,</span>
        <span class="n">optimal_ordering</span><span class="o">=</span><span class="n">optimal_ordering</span><span class="p">,</span>
        <span class="n">key_added</span><span class="o">=</span><span class="n">key_added</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="dpt"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.dpt.html#ehrapy.tools.dpt">[docs]</a><span class="k">def</span> <span class="nf">dpt</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">n_dcs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">n_branchings</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">min_group_size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">allow_kendall_tau_shift</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">neighbors_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AnnData</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Infer progression of observations through geodesic distance along the graph [Haghverdi16]_ [Wolf19]_.</span>

<span class="sd">    Reconstruct the progression of a biological process from snapshot</span>
<span class="sd">    data. `Diffusion Pseudotime` has been introduced by [Haghverdi16]_ and</span>
<span class="sd">    implemented within Scanpy [Wolf18]_. Here, we use a further developed</span>
<span class="sd">    version, which is able to deal with disconnected graphs [Wolf19]_ and can</span>
<span class="sd">    be run in a `hierarchical` mode by setting the parameter `n_branchings&gt;1`.</span>
<span class="sd">    We recommend, however, to only use :func:`~ehrapy.tl.dpt` for computing pseudotime (`n_branchings=0`) and</span>
<span class="sd">    to detect branchings via :func:`~scanpy.tl.paga`. For pseudotime, you need</span>
<span class="sd">    to annotate your data with a root cell. For instance `adata.uns[&#39;iroot&#39;] = np.flatnonzero(adata.obs[&#39;cell_types&#39;] == &#39;Stem&#39;)[0]`</span>
<span class="sd">    This requires to run :func:`~ehrapy.pp.neighbors`, first. In order to</span>
<span class="sd">    reproduce the original implementation of DPT, use `method==&#39;gauss&#39;` in</span>
<span class="sd">    this. Using the default `method==&#39;umap&#39;` only leads to minor quantitative differences, though.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        n_dcs: The number of diffusion components to use.</span>
<span class="sd">        n_branchings: Number of branchings to detect.</span>
<span class="sd">        min_group_size: During recursive splitting of branches (&#39;dpt groups&#39;) for `n_branchings`</span>
<span class="sd">                        &gt; 1, do not consider groups that contain less than `min_group_size` data</span>
<span class="sd">                        points. If a float, `min_group_size` refers to a fraction of the total number of data points.</span>
<span class="sd">        allow_kendall_tau_shift: If a very small branch is detected upon splitting, shift away from</span>
<span class="sd">                                 maximum correlation in Kendall tau criterion of [Haghverdi16]_ to stabilize the splitting.</span>
<span class="sd">        neighbors_key: If not specified, dpt looks `.uns[&#39;neighbors&#39;]` for neighbors settings</span>
<span class="sd">                       and `.obsp[&#39;connectivities&#39;]`, `.obsp[&#39;distances&#39;]` for connectivities and</span>
<span class="sd">                       distances respectively (default storage places for pp.neighbors).</span>
<span class="sd">                       If specified, dpt looks .uns[neighbors_key] for neighbors settings and</span>
<span class="sd">                       `.obsp[.uns[neighbors_key][&#39;connectivities_key&#39;]]`,</span>
<span class="sd">                       `.obsp[.uns[neighbors_key][&#39;distances_key&#39;]]` for connectivities and distances respectively.</span>
<span class="sd">        copy: Copy instance before computation and return a copy. Otherwise, perform computation in place and return `None`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Depending on `copy`, returns or updates `adata` with the following fields.</span>
<span class="sd">        If `n_branchings==0`, no field `dpt_groups` will be written.</span>

<span class="sd">        * `dpt_pseudotime` : :class:`pandas.Series` (`adata.obs`, dtype `float`)</span>
<span class="sd">          Array of dim (number of samples) that stores the pseudotime of each</span>
<span class="sd">          observation, that is, the DPT distance with respect to the root observation.</span>
<span class="sd">        * `dpt_groups` : :class:`pandas.Series` (`adata.obs`, dtype `category`)</span>
<span class="sd">          Array of dim (number of samples) that stores the subgroup id (&#39;0&#39;, &#39;1&#39;, ...) for each observation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">dpt</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">n_dcs</span><span class="o">=</span><span class="n">n_dcs</span><span class="p">,</span>
        <span class="n">n_branchings</span><span class="o">=</span><span class="n">n_branchings</span><span class="p">,</span>
        <span class="n">min_group_size</span><span class="o">=</span><span class="n">min_group_size</span><span class="p">,</span>
        <span class="n">allow_kendall_tau_shift</span><span class="o">=</span><span class="n">allow_kendall_tau_shift</span><span class="p">,</span>
        <span class="n">neighbors_key</span><span class="o">=</span><span class="n">neighbors_key</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="paga"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.paga.html#ehrapy.tools.paga">[docs]</a><span class="k">def</span> <span class="nf">paga</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">groups</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_rna_velocity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;v1.2&quot;</span><span class="p">,</span> <span class="s2">&quot;v1.0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;v1.2&quot;</span><span class="p">,</span>
    <span class="n">neighbors_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AnnData</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Mapping out the coarse-grained connectivity structures of complex manifolds [Wolf19]_.</span>

<span class="sd">    By quantifying the connectivity of partitions (groups, clusters),</span>
<span class="sd">    partition-based graph abstraction (PAGA) generates a much</span>
<span class="sd">    simpler abstracted graph (*PAGA graph*) of partitions, in which edge weights</span>
<span class="sd">    represent confidence in the presence of connections. By tresholding this</span>
<span class="sd">    confidence in :func:`~ehrapy.pl.paga`, a much simpler representation of the</span>
<span class="sd">    manifold data is obtained, which is nonetheless faithful to the topology of</span>
<span class="sd">    the manifold.</span>
<span class="sd">    The confidence should be interpreted as the ratio of the actual versus the</span>
<span class="sd">    expected value of connections under the null model of randomly connecting</span>
<span class="sd">    partitions. We do not provide a p-value as this null model does not</span>
<span class="sd">    precisely capture what one would consider &quot;connected&quot; in real data, hence it</span>
<span class="sd">    strongly overestimates the expected value. See an extensive discussion of this in [Wolf19]_.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Note that you can use the result of :func:`~ehrapy.pl.paga` in</span>
<span class="sd">        :func:`~ehrapy.tl.umap` and :func:`~ehrapy.tl.draw_graph` via</span>
<span class="sd">        `init_pos=&#39;paga&#39;` to get embeddings that are typically more faithful to the global topology.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        groups: Key for categorical in `adata.obs`. You can pass your predefined groups</span>
<span class="sd">                by choosing any categorical annotation of observations. Default:</span>
<span class="sd">                The first present key of `&#39;leiden&#39;` or `&#39;louvain&#39;`.</span>
<span class="sd">        model: The PAGA connectivity model.</span>
<span class="sd">        neighbors_key: If not specified, paga looks `.uns[&#39;neighbors&#39;]` for neighbors settings</span>
<span class="sd">                       and `.obsp[&#39;connectivities&#39;]`, `.obsp[&#39;distances&#39;]` for connectivities and</span>
<span class="sd">                       distances respectively (default storage places for `pp.neighbors`).</span>
<span class="sd">                       If specified, paga looks `.uns[neighbors_key]` for neighbors settings and</span>
<span class="sd">                       `.obsp[.uns[neighbors_key][&#39;connectivities_key&#39;]]`,</span>
<span class="sd">                       `.obsp[.uns[neighbors_key][&#39;distances_key&#39;]]` for connectivities and distances respectively.</span>
<span class="sd">        copy: Copy `adata` before computation and return a copy. Otherwise, perform computation in place and return `None`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        **connectivities** : :class:`numpy.ndarray` (adata.uns[&#39;connectivities&#39;])</span>
<span class="sd">        The full adjacency matrix of the abstracted graph, weights correspond to confidence in the connectivities of partitions.</span>

<span class="sd">       **connectivities_tree** : :class:`scipy.sparse.csr_matrix` (adata.uns[&#39;connectivities_tree&#39;])</span>
<span class="sd">        The adjacency matrix of the tree-like subgraph that best explains the topology.</span>

<span class="sd">    Notes:</span>
<span class="sd">    Together with a random walk-based distance measure (e.g. :func:`ehrapy.tl.dpt`)</span>
<span class="sd">    this generates a partial coordinatization of data useful for exploring and explaining its variation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">paga</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">groups</span><span class="o">=</span><span class="n">groups</span><span class="p">,</span>
        <span class="n">use_rna_velocity</span><span class="o">=</span><span class="n">use_rna_velocity</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="n">neighbors_key</span><span class="o">=</span><span class="n">neighbors_key</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="ingest"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.ingest.html#ehrapy.tools.ingest">[docs]</a><span class="k">def</span> <span class="nf">ingest</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">adata_ref</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">obs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">embedding_method</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;umap&quot;</span><span class="p">,</span> <span class="s2">&quot;pca&quot;</span><span class="p">),</span>
    <span class="n">labeling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;knn&quot;</span><span class="p">,</span>
    <span class="n">neighbors_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AnnData</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Map labels and embeddings from reference data to new data.</span>

<span class="sd">    Integrates embeddings and annotations of an `adata` with a reference dataset</span>
<span class="sd">    `adata_ref` through projecting on a PCA (or alternate model) that has been fitted on the reference data.</span>
<span class="sd">    The function uses a knn classifier for mapping labels and the UMAP package [McInnes18]_ for mapping the embeddings.</span>

<span class="sd">    .. note::</span>
<span class="sd">        We refer to this *asymmetric* dataset integration as *ingesting*</span>
<span class="sd">        annotations from reference data to new data. This is different from</span>
<span class="sd">        learning a joint representation that integrates both datasets in an</span>
<span class="sd">        unbiased way, as CCA (e.g. in Seurat) or a conditional VAE (e.g. in</span>
<span class="sd">        scVI) would do.</span>

<span class="sd">    You need to run :func:`~ehrapy.pp.neighbors` on `adata_ref` before passing it.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: :class:`~anndata.AnnData` object object containing all observations.</span>
<span class="sd">        adata_ref: The annotated data matrix of shape `n_obs` × `n_vars`. Rows correspond to observations and columns to features.</span>
<span class="sd">                   Variables (`n_vars` and `var_names`) of `adata_ref` should be the same as in `adata`.</span>
<span class="sd">                   This is the dataset with labels and embeddings which need to be mapped to `adata`.</span>
<span class="sd">        obs: Labels&#39; keys in `adata_ref.obs` which need to be mapped to `adata.obs` (inferred for observation of `adata`).</span>
<span class="sd">        embedding_method: Embeddings in `adata_ref` which need to be mapped to `adata`. The only supported values are &#39;umap&#39; and &#39;pca&#39;.</span>
<span class="sd">        labeling_method: The method to map labels in `adata_ref.obs` to `adata.obs`. The only supported value is &#39;knn&#39;.</span>
<span class="sd">        neighbors_key: If not specified, ingest looks adata_ref.uns[&#39;neighbors&#39;] for neighbors settings and adata_ref.obsp[&#39;distances&#39;] for</span>
<span class="sd">                       distances (default storage places for pp.neighbors). If specified, ingest looks adata_ref.uns[neighbors_key] for</span>
<span class="sd">                       neighbors settings and adata_ref.obsp[adata_ref.uns[neighbors_key][&#39;distances_key&#39;]] for distances.</span>
<span class="sd">        inplace: Only works if `return_joint=False`.</span>
<span class="sd">                 Add labels and embeddings to the passed `adata` (if `True`) or return a copy of `adata` with mapped embeddings and labels.</span>
<span class="sd">        **kwargs: Further keyword arguments for the Neighbor calculation</span>

<span class="sd">    Returns:</span>
<span class="sd">        * if `inplace=False` returns a copy of `adata` with mapped embeddings and labels in `obsm` and `obs` correspondingly</span>
<span class="sd">        * if `inplace=True` returns `None` and updates `adata.obsm` and `adata.obs` with mapped embeddings and labels</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>

<span class="sd">            ep.pp.neighbors(adata_ref)</span>
<span class="sd">            ep.tl.umap(adata_ref)</span>
<span class="sd">            ep.tl.ingest(adata, adata_ref, obs=&quot;service_unit&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">ingest</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">adata_ref</span><span class="o">=</span><span class="n">adata_ref</span><span class="p">,</span>
        <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span>
        <span class="n">embedding_method</span><span class="o">=</span><span class="n">embedding_method</span><span class="p">,</span>
        <span class="n">labeling_method</span><span class="o">=</span><span class="n">labeling_method</span><span class="p">,</span>
        <span class="n">neighbors_key</span><span class="o">=</span><span class="n">neighbors_key</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="n">_rank_features_groups_method</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;logreg&quot;</span><span class="p">,</span> <span class="s2">&quot;t-test&quot;</span><span class="p">,</span> <span class="s2">&quot;wilcoxon&quot;</span><span class="p">,</span> <span class="s2">&quot;t-test_overestim_var&quot;</span><span class="p">]]</span>
<span class="n">_corr_method</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;benjamini-hochberg&quot;</span><span class="p">,</span> <span class="s2">&quot;bonferroni&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="rank_features_groups"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.rank_features_groups.html#ehrapy.tools.rank_features_groups">[docs]</a><span class="k">def</span> <span class="nf">rank_features_groups</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">groupby</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">groups</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">reference</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rest&quot;</span><span class="p">,</span>
    <span class="n">n_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rankby_abs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">pts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">key_added</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;rank_features_groups&quot;</span><span class="p">,</span>
    <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">_rank_features_groups_method</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">corr_method</span><span class="p">:</span> <span class="n">_corr_method</span> <span class="o">=</span> <span class="s2">&quot;benjamini-hochberg&quot;</span><span class="p">,</span>
    <span class="n">tie_correct</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">layer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Rank features for characterizing groups.</span>

<span class="sd">    Expects logarithmized data.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: Annotated data matrix.</span>
<span class="sd">        groupby: The key of the observations grouping to consider.</span>
<span class="sd">        groups: Subset of groups, e.g. [`&#39;g1&#39;`, `&#39;g2&#39;`, `&#39;g3&#39;`], to which comparison</span>
<span class="sd">                shall be restricted, or `&#39;all&#39;` (default), for all groups.</span>
<span class="sd">        reference: If `&#39;rest&#39;`, compare each group to the union of the rest of the group.</span>
<span class="sd">                   If a group identifier, compare with respect to this group.</span>
<span class="sd">        n_features: The number of features that appear in the returned tables. Defaults to all features.</span>
<span class="sd">        rankby_abs: Rank genes by the absolute value of the score, not by the score.</span>
<span class="sd">                    The returned scores are never the absolute values.</span>
<span class="sd">        pts: Compute the fraction of observations containing the features.</span>
<span class="sd">        key_added: The key in `adata.uns` information is saved to.</span>
<span class="sd">        copy: Whether to return a copy of the AnnData object.</span>
<span class="sd">        method:  The default method is `&#39;t-test&#39;`,</span>
<span class="sd">                 `&#39;t-test_overestim_var&#39;` overestimates variance of each group,</span>
<span class="sd">                 `&#39;wilcoxon&#39;` uses Wilcoxon rank-sum,</span>
<span class="sd">                 `&#39;logreg&#39;` uses logistic regression.</span>
<span class="sd">        corr_method:  p-value correction method.</span>
<span class="sd">                      Used only for `&#39;t-test&#39;`, `&#39;t-test_overestim_var&#39;`, and `&#39;wilcoxon&#39;`.</span>
<span class="sd">        tie_correct: Use tie correction for `&#39;wilcoxon&#39;` scores. Used only for `&#39;wilcoxon&#39;`.</span>
<span class="sd">        layer: Key from `adata.layers` whose value will be used to perform tests on.</span>
<span class="sd">        **kwds: Are passed to test methods. Currently this affects only parameters that</span>
<span class="sd">                are passed to :class:`sklearn.linear_model.LogisticRegression`.</span>
<span class="sd">                For instance, you can pass `penalty=&#39;l1&#39;` to try to come up with a</span>
<span class="sd">                minimal set of genes that are good predictors (sparse solution meaning few non-zero fitted coefficients).</span>

<span class="sd">    Returns:</span>
<span class="sd">        *names*: structured `np.ndarray` (`.uns[&#39;rank_features_groups&#39;]`)</span>
<span class="sd">                  Structured array to be indexed by group id storing the gene</span>
<span class="sd">                  names. Ordered according to scores.</span>
<span class="sd">        *scores*: structured `np.ndarray` (`.uns[&#39;rank_features_groups&#39;]`)</span>
<span class="sd">                  Structured array to be indexed by group id storing the z-score</span>
<span class="sd">                  underlying the computation of a p-value for each gene for each group.</span>
<span class="sd">                  Ordered according to scores.</span>
<span class="sd">        *logfoldchanges*: structured `np.ndarray` (`.uns[&#39;rank_features_groups&#39;]`)</span>
<span class="sd">                          Structured array to be indexed by group id storing the log2</span>
<span class="sd">                          fold change for each gene for each group. Ordered according to scores.</span>
<span class="sd">                          Only provided if method is &#39;t-test&#39; like.</span>
<span class="sd">                          Note: this is an approximation calculated from mean-log values.</span>
<span class="sd">        *pvals*: structured `np.ndarray` (`.uns[&#39;rank_features_groups&#39;]`)</span>
<span class="sd">                 p-values.</span>
<span class="sd">        *pvals_adj* : structured `np.ndarray` (`.uns[&#39;rank_features_groups&#39;]`)</span>
<span class="sd">                      Corrected p-values.</span>
<span class="sd">        *pts*: `pandas.DataFrame` (`.uns[&#39;rank_features_groups&#39;]`)</span>
<span class="sd">               Fraction of cells expressing the genes for each group.</span>
<span class="sd">        *pts_rest*: `pandas.DataFrame` (`.uns[&#39;rank_features_groups&#39;]`)</span>
<span class="sd">                    Only if `reference` is set to `&#39;rest&#39;`.</span>
<span class="sd">                    Fraction of observations from the union of the rest of each group containing the features.</span>

<span class="sd">     Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>
<span class="sd">            adata = eh.dt.mimic_2(encode=True)</span>
<span class="sd">            ep.tl.rank_features_groups(adata, &quot;service_unit&quot;)</span>
<span class="sd">            ep.pl.rank_features_groups(adata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">rank_genes_groups</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span>
        <span class="n">use_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">groups</span><span class="o">=</span><span class="n">groups</span><span class="p">,</span>
        <span class="n">reference</span><span class="o">=</span><span class="n">reference</span><span class="p">,</span>
        <span class="n">n_genes</span><span class="o">=</span><span class="n">n_features</span><span class="p">,</span>
        <span class="n">rankby_abs</span><span class="o">=</span><span class="n">rankby_abs</span><span class="p">,</span>
        <span class="n">pts</span><span class="o">=</span><span class="n">pts</span><span class="p">,</span>
        <span class="n">key_added</span><span class="o">=</span><span class="n">key_added</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="n">corr_method</span><span class="o">=</span><span class="n">corr_method</span><span class="p">,</span>
        <span class="n">tie_correct</span><span class="o">=</span><span class="n">tie_correct</span><span class="p">,</span>
        <span class="n">layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="filter_rank_features_groups"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.filter_rank_features_groups.html#ehrapy.tools.filter_rank_features_groups">[docs]</a><span class="k">def</span> <span class="nf">filter_rank_features_groups</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">key</span><span class="o">=</span><span class="s2">&quot;rank_features_groups&quot;</span><span class="p">,</span>
    <span class="n">groupby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_added</span><span class="o">=</span><span class="s2">&quot;rank_features_groups_filtered&quot;</span><span class="p">,</span>
    <span class="n">min_in_group_fraction</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
    <span class="n">min_fold_change</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">max_out_group_fraction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Filters out features based on fold change and fraction of features containing the feature within and outside the `groupby` categories.</span>

<span class="sd">    See :func:`~ehrapy.tl.rank_features_groups`.</span>

<span class="sd">    Results are stored in `adata.uns[key_added]`</span>
<span class="sd">    (default: &#39;rank_genes_groups_filtered&#39;).</span>

<span class="sd">    To preserve the original structure of adata.uns[&#39;rank_genes_groups&#39;],</span>
<span class="sd">    filtered genes are set to `NaN`.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: Annotated data matrix.</span>
<span class="sd">        key: Key previously added by :func:`~ehrapy.tl.rank_features_groups`</span>
<span class="sd">        groupby: The key of the observations grouping to consider.</span>
<span class="sd">        key_added: The key in `adata.uns` information is saved to.</span>
<span class="sd">        min_in_group_fraction: Minimum in group fraction (default: 0.25).</span>
<span class="sd">        min_fold_change: Miniumum fold change (default: 1).</span>
<span class="sd">        max_out_group_fraction: Maximum out group fraction (default: 0.5).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Same output as :func:`ehrapy.tl.rank_features_groups` but with filtered feature names set to `nan`</span>

<span class="sd">    Example:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            import ehrapy as ep</span>
<span class="sd">            adata = eh.dt.mimic_2(encode=True)</span>
<span class="sd">            ep.tl.rank_features_groups(adata, &quot;service_unit&quot;)</span>
<span class="sd">            ep.pl.rank_features_groups(adata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">filter_rank_genes_groups</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
        <span class="n">groupby</span><span class="o">=</span><span class="n">groupby</span><span class="p">,</span>
        <span class="n">use_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">key_added</span><span class="o">=</span><span class="n">key_added</span><span class="p">,</span>
        <span class="n">min_in_group_fraction</span><span class="o">=</span><span class="n">min_in_group_fraction</span><span class="p">,</span>
        <span class="n">min_fold_change</span><span class="o">=</span><span class="n">min_fold_change</span><span class="p">,</span>
        <span class="n">max_out_group_fraction</span><span class="o">=</span><span class="n">max_out_group_fraction</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="n">_marker_feature_overlap_methods</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;overlap_count&quot;</span><span class="p">,</span> <span class="s2">&quot;overlap_coef&quot;</span><span class="p">,</span> <span class="s2">&quot;jaccard&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="marker_feature_overlap"><a class="viewcode-back" href="../../../usage/tools/ehrapy.tools.marker_feature_overlap.html#ehrapy.tools.marker_feature_overlap">[docs]</a><span class="k">def</span> <span class="nf">marker_feature_overlap</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">reference_markers</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rank_features_groups&quot;</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">_marker_feature_overlap_methods</span> <span class="o">=</span> <span class="s2">&quot;overlap_count&quot;</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;reference&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">top_n_markers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">adj_pval_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">key_added</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;feature_overlap&quot;</span><span class="p">,</span>
    <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="sd">&quot;&quot;&quot;Calculate an overlap score between data-deriven features and provided marker features.</span>

<span class="sd">    Marker feature overlap scores can be quoted as overlap counts, overlap</span>
<span class="sd">    coefficients, or jaccard indices. The method returns a pandas dataframe</span>
<span class="sd">    which can be used to annotate clusters based on feature overlaps.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: Annotated data matrix.</span>
<span class="sd">        reference_markers: A marker gene dictionary object. Keys should be strings with the</span>
<span class="sd">                           cell identity name and values are sets or lists of strings which match format of `adata.var_name`.</span>
<span class="sd">        key: The key in `adata.uns` where the rank_features_groups output is stored (default: rank_features_groups).</span>
<span class="sd">        method: Method to calculate marker gene overlap. `&#39;overlap_count&#39;` uses the</span>
<span class="sd">                intersection of the feature set, `&#39;overlap_coef&#39;` uses the overlap</span>
<span class="sd">                coefficient, and `&#39;jaccard&#39;` uses the Jaccard index (default: `overlap_count`).</span>
<span class="sd">        normalize: Normalization option for the feature overlap output. This parameter</span>
<span class="sd">                   can only be set when `method` is set to `&#39;overlap_count&#39;`. `&#39;reference&#39;`</span>
<span class="sd">                   normalizes the data by the total number of marker features given in the</span>
<span class="sd">                   reference annotation per group. `&#39;data&#39;` normalizes the data by the</span>
<span class="sd">                   total number of marker genes used for each cluster.</span>
<span class="sd">        top_n_markers: The number of top data-derived marker genes to use. By default the top</span>
<span class="sd">                       100 marker features are used. If `adj_pval_threshold` is set along with</span>
<span class="sd">                       `top_n_markers`, then `adj_pval_threshold` is ignored.</span>
<span class="sd">        adj_pval_threshold: A significance threshold on the adjusted p-values to select marker features.</span>
<span class="sd">                            This can only be used when adjusted p-values are calculated by `ep.tl.rank_features_groups`.</span>
<span class="sd">                            If `adj_pval_threshold` is set along with `top_n_markers`, then `adj_pval_threshold` is ignored.</span>
<span class="sd">        key_added: Name of the `.uns` field that will contain the marker overlap scores.</span>
<span class="sd">        inplace: Return a marker gene dataframe or store it inplace in `adata.uns`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A pandas dataframe with the marker gene overlap scores if `inplace=False`.</span>
<span class="sd">        For `inplace=True` `adata.uns` is updated with an additional field</span>
<span class="sd">        specified by the `key_added` parameter (default = &#39;marker_gene_overlap&#39;).</span>

<span class="sd">    Example:</span>
<span class="sd">        TODO</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">marker_gene_overlap</span><span class="p">(</span>
        <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">,</span>
        <span class="n">reference_markers</span><span class="o">=</span><span class="n">reference_markers</span><span class="p">,</span>
        <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="n">top_n_markers</span><span class="o">=</span><span class="n">top_n_markers</span><span class="p">,</span>
        <span class="n">adj_pval_threshold</span><span class="o">=</span><span class="n">adj_pval_threshold</span><span class="p">,</span>
        <span class="n">key_added</span><span class="o">=</span><span class="n">key_added</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
    <span class="p">)</span></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2021, Lukas Heumos, Theislab
            </div>
            Made with 
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    </body>
</html>